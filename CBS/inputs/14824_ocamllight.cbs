Language "OCaml Light"

#6 Patterns

Syntax
  P : pattern 
  ::= value-name 
	|  '_'
	| constant
	| pattern 'as' value-name
	| '(' pattern ')'
	| '(' pattern ':' typexpr ')'
	| pattern '|' pattern
	| constr pattern
	| pattern comma-pattern+
	| '{' field '=' pattern semic-field-pattern* ';'? '}'
	| '[' pattern semic-pattern* ';'? ']'
	| pattern '::' pattern

  CP : comma-pattern ::= ',' pattern
  
  SP : semic-pattern ::= ';' pattern
  
  SFP : semic-field-pattern ::= ';' field '=' pattern

Rule
  [[ '(' P ')' ]] : pattern = [[ P ]]
Rule
  [[ '(' P ':' T ')' ]] : pattern = [[ P ]]
Rule
  [[ '{' F '=' P SFP* ';' '}' ]] : pattern = [[ '{' F '=' P SFP* '}' ]]
Rule
  [[ '[' P SP* ';' ']' ]] : pattern = [[ '[' P SP* ']' ]]

## Pattern evaluation

Semantics
  evaluate-pattern[[ _:pattern ]] : =>patterns
Rule
  evaluate-pattern[[ VN ]] = pattern-bind(value-name[[ VN ]]) 
Rule
  evaluate-pattern[[ '_' ]] = pattern-any
Rule
  evaluate-pattern[[ CNST ]] = value[[ CNST ]]
Rule
  evaluate-pattern[[ P 'as' VN ]] = 
    pattern-unite(evaluate-pattern[[ P ]], pattern-bind(value-name[[ VN ]]))
Rule
  evaluate-pattern[[ P1 '|' P2 ]] =
    pattern-else(evaluate-pattern[[ P1 ]], evaluate-pattern[[ P2 ]])
Rule
  evaluate-pattern[[ CSTR P ]] =
    variant(constr-name[[ CSTR ]], evaluate-pattern[[ P ]])
Rule
  evaluate-pattern[[ P1 ',' P2 CP* ]] =
    tuple( evaluate-comma-pattern-sequence[[ P1 ',' P2 CP* ]] )
Rule
  evaluate-pattern[[ '{' F '=' P SFP* '}' ]] =
    pattern closure(match-loosely(
      given,
	  record(map-unite(evaluate-field-pattern-sequence[[ F '=' P SFP* ]]))))
Rule
  evaluate-pattern[[ '[' P SP* ']' ]] =
    [ evaluate-semic-pattern-sequence[[ P SP* ]] ]
Rule
  evaluate-pattern[[ P1 '::' P2 ]] =
    pattern closure(
      if-true-else(is-equal(given,[]),
        fail,
        collateral(
          match(head(given), evaluate-pattern[[ P1 ]]),
          match(tail(given), evaluate-pattern[[ P2 ]]))))

## Pattern sequence evaluation

Semantics
  evaluate-comma-pattern-sequence[[ _:(pattern comma-pattern*) ]] : 
                                                   (=>patterns)+
Rule
  evaluate-comma-pattern-sequence[[ P1 ',' P2 CP* ]] =
    evaluate-pattern[[ P1 ]], evaluate-comma-pattern-sequence[[ P2 CP* ]]
Rule
  evaluate-comma-pattern-sequence[[ P ]] = evaluate-pattern[[ P ]] 

Semantics
  evaluate-semic-pattern-sequence[[ _:(pattern semic-pattern*) ]] :
                                                    (=>patterns)+
Rule
  evaluate-semic-pattern-sequence[[ P1 ';' P2 SP* ]] =
    evaluate-pattern[[ P1 ]], evaluate-semic-pattern-sequence[[ P2 SP* ]]
Rule
  evaluate-semic-pattern-sequence[[ P ]] = evaluate-pattern[[ P ]]
    
Semantics
  evaluate-field-pattern-sequence[[ _:(field '=' pattern semic-field-pattern*) ]] : 
                                          =>(maps(ids,patterns))+
Rule
  evaluate-field-pattern-sequence[[ F1 '=' P1 ';' F2 '=' P2 SFP* ]] =
    ( { field-name[[ F1 ]] |-> evaluate-pattern[[ P1 ]] },
      evaluate-field-pattern-sequence[[ F2 '=' P2 SFP* ]] )
Rule
  evaluate-field-pattern-sequence[[ F '=' P ]] =
    { field-name[[ F ]] |-> evaluate-pattern[[ P ]] }

#11 Module implementations

Syntax
  UI : unit-implementation
  ::= (semicolon-pair* module-items semicolon-pair*)?
  
  MIS : module-items 
  ::= definition
    | expr
    | module-items semicolon-pair* module-item

  MI : module-item
  ::= definition
    | semicolon-pair expr

  D : definition
  ::= let-definition
	| type-definition
	| exception-definition
Lexis
  SCP : semicolon-pair ::= ';;'

Semantics
  interpret[[ UI:unit-implementation ]] : =>environments
Rule
  interpret[[  ]] = map( )
Rule
  interpret[[ SCP1* MIS SCP2* ]] = 
    handle-thrown(
	  scope(
	    ocaml-light-core-library,
	  	accumulate(define-or-evaluate-items[[ MIS ]])),
      sequential(
        print ("Uncaught exception: ", ocaml-light-to-string given, "\n"),
        map()))

Semantics
  define-or-evaluate-items[[ _:module-items ]] : (=>envs)+
Rule
  define-or-evaluate-items[[ LD ]] =
    ocaml-light-define-and-display define-values[[ LD ]]
Rule
  define-or-evaluate-items[[ TDS ]] = define-types[[ TDS ]]
Rule
  define-or-evaluate-items[[ ED ]] = define-exception[[ ED ]]
Rule
  define-or-evaluate-items[[ E ]] =
    ocaml-light-evaluate-and-display evaluate[[ E ]]
Rule
  define-or-evaluate-items[[ MIS SCP* D ]] =
    ( define-or-evaluate-items[[ MIS ]], define-or-evaluate-items[[ D ]] )
Rule
  define-or-evaluate-items[[ MIS SCP* SCP E ]] =
    ( define-or-evaluate-items[[ MIS ]], define-or-evaluate-items[[ E ]] )

#7 Expressions

Syntax
 E : expr
 ::= value-path
   | constant
   | '(' expr ')'
   | 'begin' expr 'end'
   | '(' expr ':' typexpr ')'
   | expr comma-expr+
// | constr expr // ambiguous!
   | expr '::' expr
   | '[' expr semic-expr* ']'
   | '[' expr semic-expr* ';' ']'
   | '[|' expr semic-expr* '|]'
   | '[|' expr semic-expr* ';' '|]'
   | '{' field '=' expr semic-field-expr* '}'
   | '{' field '=' expr semic-field-expr* ';' '}'
   | '{' expr 'with' field '=' expr semic-field-expr* '}'
   | '{' expr 'with' field '=' expr semic-field-expr* ';' '}'
   | expr argument+
   | prefix-symbol expr
   | '-' expr
   | '-.' expr
   | expr infix-op-1 expr
   | expr infix-op-2 expr
   | expr infix-op-3 expr
   | expr infix-op-4 expr
   | expr infix-op-5 expr
   | expr infix-op-6 expr
   | expr infix-op-7 expr
   | expr infix-op-8 expr
   | expr '.' field
   | expr '.(' expr ')'
   | expr '.(' expr ')' '<-' expr
   | 'if' expr 'then' expr ( 'else' expr )?
   | 'while' expr 'do' expr 'done'
   | 'for' value-name '=' expr ('to'|'downto') expr 'do' expr 'done'
   | expr ';' expr
   | 'match' expr 'with' pattern-matching
   | 'function' pattern-matching
   | 'fun' pattern+ '->' expr
   | 'try' expr 'with' pattern-matching
   | let-definition 'in' expr

  A : argument ::= expr
  
  PM : pattern-matching
  ::= pattern '->' expr pattern-expr*
    | '|' pattern '->' expr pattern-expr*

  LD : let-definition ::= 'let' ('rec')? let-binding and-let-binding* 

  LB : let-binding 
  ::= pattern '=' expr
    | value-name pattern+ '=' expr // using pattern* was ambiguous!
    | value-name ':' poly-typexpr '=' expr
  
  ALB : and-let-binding ::= 'and' let-binding

  CE : comma-expr ::= ',' expr
  
  SE : semic-expr ::= ';' expr
  
  SFE : semic-field-expr ::= ';' field '=' expr
  
  PE : pattern-expr ::= '|' pattern '->' expr


Rule
  [[ '(' E ')' ]] : expr =  [[ E ]]
Rule
  [[ 'begin' E 'end' ]] : expr = [[ E ]]
Rule
  [[ '(' E ':' T ')' ]] : expr = [[ E ]]
Rule
  [[ E1 E2 A A* ]] : expr = [[ ( '(' E1 E2 ')' ) A A* ]]
  // FIX-ME: "... E+" not yet supported 
Rule
  [[ PS E ]] : expr   = [[ ( '(' PS ')' ) E ]]
Rule
  [[ '-' E ]] : expr  = [[ ( '(' '~-' ')' ) E ]]
Rule
  [[ '-.' E ]] : expr = [[ ( '(' '~-.' ')' ) E ]]
Rule
  [[ E1 IO-1 E2 ]] : expr = [[ ( '(' IO-1 ')' ) E1 E2 ]]
Rule
  [[ E1 IO-2 E2 ]] : expr = [[ ( '(' IO-2 ')' ) E1 E2 ]]
Rule
  [[ E1 IO-3 E2 ]] : expr = [[ ( '(' IO-3 ')' ) E1 E2 ]]
Rule
  [[ E1 IO-4 E2 ]] : expr = [[ ( '(' IO-4 ')' ) E1 E2 ]]
Rule
  [[ E1 IO-5 E2 ]] : expr = [[ ( '(' IO-5 ')' ) E1 E2 ]]
Rule
  [[ E1 '&' E2 ]] : expr  = [[ E1 '&&' E2 ]]
Rule
  [[ E1 'or' E2 ]] : expr = [[ E1 '||' E2 ]]
Rule
  [[ E1 IO-8 E2 ]] : expr = [[ ( '(' IO-8 ')' ) E1 E2 ]]
Rule
  [[ E1 '.(' E2 ')' ]] : expr = [[ 'array_get' E1 E2 ]]
Rule
  [[ E1 '.(' E2 ')' '<-' E3 ]] : expr = [[ 'array_set' E1 E2 E3 ]]
Rule
  [[ 'if' E1 'then' E2 ]] : expr = [[ 'if' E1 'then' E2 'else' ( '(' ')' ) ]]
Rule
  [[ 'fun' P '->' E ]] : expr = [[ 'function' P '->' E ]]
Rule
  [[ 'fun' P P+ '->' E ]] : expr = [[ 'fun' P '->' ( 'fun' P+ '->' E ) ]]
Rule
 [[ '[' E SE* ';' ']' ]] : expr = [[ '[' E SE* ']' ]]
Rule
 [[ '[|' E SE* ';' '|]' ]] : expr = [[ '[|' E SE* '|]' ]]
Rule
 [[ '{' F '=' E SFE* ';' '}' ]] : expr = [[ '{' F '=' E SFE* '}' ]]
Rule
 [[ '{' E1 'with' F '=' E2 SFE* ';' '}' ]] : expr = 
 [[ '{' E1 'with' F '=' E2 SFE* '}' ]]
Rule
  [[ '|' P '->' E PE* ]] : pattern-matching = [[ P '->' E PE* ]]
Rule
  [[ VN ':' PT '=' E ]] : let-binding = [[ VN '=' E ]]
Rule
  [[ VN P+ '=' E ]] : let-binding = [[ VN '=' ( 'fun' P+ '->' E ) ]]


Semantics
  evaluate[[ _:expr ]] : =>implemented-values
Rule
  evaluate[[ VP ]] = bound(value-name[[ VP ]])
Rule
  evaluate[[ CNST ]] = value[[ CNST ]]
Rule
  evaluate[[ '(' E ':' T ')' ]] = evaluate[[ E ]]
Rule
  evaluate[[ E1 ',' E2 CE* ]] =
    tuple( evaluate-comma-sequence[[ E1 ',' E2 CE* ]] )
Rule
  evaluate[[ E1 '::' E2 ]] = cons(evaluate[[ E1 ]], evaluate[[ E2 ]])
Rule
  evaluate[[ '[' E SE* ']' ]] = [ evaluate-semic-sequence [[ E SE* ]] ]
Rule
  evaluate[[ '[|' E SE* '|]' ]] =
    vector(left-to-right-map(
      allocate-initialised-variable(implemented-values, given),
      evaluate-semic-sequence[[ E SE* ]]))
Rule
  evaluate[[ '[|' '|]' ]] = vector( )
Rule
  evaluate[[ '{' F '=' E SFE* '}' ]] = 
    record(collateral( evaluate-field-sequence[[ F '=' E SFE* ]] ))
Rule
  evaluate[[ '{' E1 'with' F '=' E2 SFE* '}' ]] = 
    record(
      map-override(
        evaluate-field-sequence[[ F '=' E2 SFE* ]],
        checked record-map(evaluate[[E1]])))
Rule
  evaluate[[ CSTR E ]] =
    variant(constr-name[[ CSTR ]], evaluate[[ E ]])
Otherwise
  evaluate[[ E1 E2 ]] =
    apply(evaluate[[ E1 ]], evaluate[[ E2 ]])
Rule
  evaluate[[ E '.' F ]] =
    record-select(evaluate[[ E ]], field-name[[ F ]])
Rule
  evaluate[[ E1 '&&' E2 ]] =
    if-true-else(evaluate[[ E1 ]], evaluate[[ E2 ]], false)
Rule
  evaluate[[ E1 '||' E2 ]] =
    if-true-else(evaluate[[ E1 ]], true, evaluate[[ E2 ]])
Rule
  evaluate[[ 'if' E1 'then' E2 'else' E3 ]] =
    if-true-else(evaluate[[ E1 ]], evaluate[[ E2 ]], evaluate[[ E3 ]])
Rule
  evaluate[[ 'while' E1 'do' E2 'done' ]] =
    while(evaluate[[ E1 ]], effect(evaluate[[ E2 ]]))
Rule
  evaluate[[ 'for' VN '=' E1 'to' E2 'do' E3 'done' ]] =
    effect(left-to-right-map(
      case-match(pattern-bind(value-name[[ VN ]]), evaluate[[ E3 ]]),
      integer-sequence(evaluate[[ E1 ]], evaluate[[ E2 ]])))
Rule
  evaluate[[ 'for' VN '=' E1 'downto' E2 'do' E3 'done' ]] =
    effect(left-to-right-map(
      case-match(pattern-bind(value-name[[ VN ]]), evaluate[[ E3 ]]),
      reverse integer-sequence(evaluate[[ E2 ]], evaluate[[ E1 ]])))
Rule
  evaluate[[ E1 ';' E2 ]] =
    sequential(effect(evaluate[[ E1 ]]), evaluate[[ E2 ]])
Rule
  evaluate[[ 'match' E 'with' PM ]] =
    give(evaluate[[ E ]], 
      else(match[[ PM ]], throw(ocaml-light-match-failure)))
Rule
  evaluate[[ 'function' PM ]] =
    function closure(
      else(match[[ PM ]], throw(ocaml-light-match-failure)))
Rule
  evaluate[[ 'try' E 'with' PM ]] =
    handle-thrown(
      evaluate[[ E ]], 
      else(match[[ PM ]], throw(given)))
Rule
  evaluate[[ LD 'in' E ]] = scope(define-values[[ LD ]], evaluate[[ E ]])


## Expression sequences and maps

Semantics
  evaluate-comma-sequence[[ _:(expr comma-expr*) ]] : (=>implemented-values)+
Rule
  evaluate-comma-sequence[[ E1 ',' E2 CE* ]] =
    evaluate[[ E1 ]], evaluate-comma-sequence[[ E2 CE* ]]
Rule
  evaluate-comma-sequence[[ E ]] = evaluate[[ E ]]

Semantics
  evaluate-semic-sequence[[ _:(expr semic-expr*) ]] : (=>implemented-values)+
Rule
  evaluate-semic-sequence[[ E1 ';' E2 SE* ]] =
    evaluate[[ E1 ]], evaluate-semic-sequence[[ E2 SE* ]]
Rule
  evaluate-semic-sequence[[ E ]] = evaluate[[ E ]]

Semantics
  evaluate-field-sequence[[ _:(field '=' expr semic-field-expr*) ]] : (=>envs)+
Rule
  evaluate-field-sequence[[ F1 '=' E1 ';' F2 '=' E2 SFE* ]] =
    { field-name[[ F1 ]] |-> evaluate[[ E1 ]] }, 
    evaluate-field-sequence[[ F2 '=' E2 SFE* ]]
Rule
  evaluate-field-sequence[[ F '=' E ]] = { field-name[[ F ]] |-> evaluate[[ E ]] }

## Matching

Semantics
  match[[ _:pattern-matching ]] : (implemented-values=>implemented-values)+
Rule
  match[[ P1 '->' E1 '|' P2 '->' E2 PE* ]] =
    match[[ P1 '->' E1 ]], match[[ P2 '->' E2 PE* ]]
Rule
  match[[ P '->' E ]] = case-match(evaluate-pattern[[ P ]], evaluate[[ E ]]) 

## Value definitions

Semantics
  define-values[[ _:let-definition ]] : =>environments
Rule
  define-values[[ 'let' LB ALB* ]] = define-values-nonrec[[ LB ALB* ]]
Rule
  define-values[[ 'let rec' LB ALB* ]] =
    recursive(
      set(bound-ids-sequence[[ LB ALB* ]]), 
      define-values-nonrec[[ LB ALB* ]])


Semantics
  define-values-nonrec[[ _:(let-binding and-let-binding*) ]] : =>environments
Rule
  define-values-nonrec[[ LB1 'and' LB2 ALB* ]] = 
    collateral(define-values-nonrec[[ LB1 ]], define-values-nonrec[[ LB2 ALB* ]])
Rule
  define-values-nonrec[[ P '=' E ]] =
  	else(
  	  match(evaluate[[ E ]], evaluate-pattern[[ P ]]), 
  	  throw(ocaml-light-match-failure))

Semantics
  bound-ids-sequence[[ _:(let-binding and-let-binding*) ]] : ids+
Rule
  bound-ids-sequence[[ LB ]] = bound-id[[ LB ]]
Rule
  bound-ids-sequence[[ LB1 'and' LB2 ALB* ]] =
    bound-id[[ LB1 ]], bound-ids-sequence[[ LB2 ALB* ]]

Semantics
  bound-id[[ _:let-binding ]] : ids
Rule
  bound-id[[ VN '=' E ]] = value-name[[ VN ]]
Otherwise
  bound-id[[ LB ]] = fail // implementation-dependent

Syntax
  START: start ::= unit-implementation
Semantics
  start[[ _:start ]] : =>environments|null-type


Rule
  start[[ UI ]] = 
    initialise-binding initialise-storing initialise-giving
    finalise-failing finalise-throwing
      interpret[[ UI ]]

[
#1  Lexical conventions
#2  Values
#3  Names
#4  Type expressions
#5  Constants
#6  Patterns
#7  Expressions
#8  Type and exception definitions
#9  Classes
#10 Module interfaces
#11 Module implementations
#12 Core library
#A  Disambiguation
]

/*
  The dynamic semantics of the OCaml Light language is specified here in CBS.
  The specification is divided into sections corresponding to Chapter 7 of the
  [OCaml System Manual](https://caml.inria.fr/pub/docs/manual-ocaml-4.06).
  The section numbers listed above are links to the respective files.
  
  The OCaml Light language corresponds closely to the language whose static
  and dynamic semantics have been specified by Scott Owens in the Ott framework
  (https://github.com/ott-lang/ott/tree/master/examples/ocaml_light).
  
  The correctness of the CBS semantics (in relation to the implementation
  provided by the OCaml developers) has been partially tested by generating
  a parser, translator, and interpreter from the specifications, and checking
  that the results of running a suite of about 150 small programs using the
  generated implementation correspond to the results of running them directly.
*/

#8 Type and exception definitions

Syntax
  TDS : type-definition 
  ::= 'type' typedef and-typedef*

  ATD : and-typedef ::= 'and' typedef
  
  TD : typedef 
  ::= type-params? typeconstr-name type-information
  
  TI : type-information 
  ::= type-equation? type-representation? type-constraint*
  
  TE : type-equation 
  ::= '=' typexpr
  
  TR : type-representation
  ::= '=' '|'? constr-decl bar-constr-decl*
    | '=' record-decl

  BCD : bar-constr-decl ::= '|' constr-decl

  TPS : type-params
  ::= type-param
	| '(' type-param (',' type-param)* ')'

  TP : type-param 
  ::= variance? '\'' ident
  
  variance ::= '+' | '-'
  
  RD : record-decl 
  ::= '{' field-decl  ( ';' field-decl )*  ';'? '}'  
 
  CD : constr-decl 
  ::= ( constr-name | '[' ']' | '(::)' ) ( 'of' constr-args )?  
 
  CA : constr-args 
  ::= typexpr star-typexpr* 
 
  FD : field-decl 
  ::= field-name ':' poly-typexpr

  ED : exception-definition
  ::= 'exception' constr-decl
    | 'exception' constr-name '=' constr

  TC : type-constraint 
  ::= 'constraint' '\'' ident '=' typexpr

## Type definitions

Semantics
  define-types[[ _:type-definition ]] : =>environments
Rule
  define-types[[ 'type' TD ATD* ]] = collateral( define-typedefs[[ TD ATD* ]] )

Semantics
  define-typedefs[[ _:(typedef and-typedef*)]] : (=>environments)+
Rule
  define-typedefs[[ TD1 'and' TD2 ATD* ]] =
    define-typedefs[[ TD2 ]], define-typedefs[[ TD2 ATD* ]]
Rule
  define-typedefs[[ TPS? TCN '=' CD BCD* ]] = 
    define-constrs[[ CD BCD* ]]
Rule
  define-typedefs[[ TPS? TCN '=' RD ]] = map( )
Rule
  define-typedefs[[ TPS? TCN '=' T ]] = map( )

Semantics
  define-constrs[[ _:(constr-decl bar-constr-decl*)]] : (=>environments)+
Rule
  define-constrs[[ CD1 '|' CD2 BCD* ]] =
    define-constrs[[ CD1 ]], define-constrs[[ CD2 BCD* ]] 
Rule
  define-constrs[[ CN ]] =
    { constr-name[[ CN ]] |-> variant(constr-name[[ CN ]],tuple( )) } 
Rule
  define-constrs[[ CN 'of' CA ]] =
    { constr-name[[ CN ]] |-> 
        function closure(variant(constr-name[[ CN ]], given)) }

## Exception definitions

Semantics
  define-exception[[ _:exception-definition ]] : =>environments
Rule
  define-exception[[ 'exception' CD ]] = define-constrs[[ CD ]]
Rule
  define-exception[[ 'exception' CN '=' CSTR ]] = map( )

#10 Module types

#2 Values

/*
  The comments below are excerpts from section 7.2 of [The OCaml System,
  release 4.06](https://caml.inria.fr/pub/docs/manual-ocaml-4.06/values.html).
*/

// FIX-ME: Allow implementation-dependent variations

Type
  implemented-values
   ~> null-type
    | booleans
    | implemented-integers
    | implemented-floats
    | implemented-characters
    | implemented-strings
    | implemented-tuples
    | implemented-lists
    | implemented-records
    | implemented-references
    | implemented-vectors
    | implemented-variants
    | implemented-functions
    

## Base values

### Integer numbers
/*
  Integer values are integer numbers from -2^{30} to 2^{30}-1, 
  that is -1073741824 to 1073741823. The implementation may support a wider
  range of integer values (...).
*/
Type
  implemented-integers // <: integers
   ~> integers // FIX-ME
Funcon
  implemented-integer(I:integers) : =>implemented-integers
    ~> I // FIX-ME: Two's complement, modulo 2^31
Assert
  is-equal(null,
    implemented-integer(N:bounded-integers(-1073741824,1073741823)))
    == false
Funcon
  implemented-integers-width : =>natural-numbers
   ~> 31
Funcon
  implemented-integer-literal(IL:strings) : => implemented-integers
   ~> implemented-integer decimal-natural(IL) // FIX-ME: allow negatives
Funcon
  implemented-bit-vector(I:implemented-integers) : 
   => bit-vectors(implemented-integers-width)
   ~> integer-to-bit-vector(I, implemented-integers-width)

### Floating-point numbers
/*
  Floating-point values are numbers in floating-point representation. 
  The current implementation uses double-precision floating-point numbers
  conforming to the IEEE 754 standard, with 53 bits of mantissa and
  an exponent ranging from -1022 to 1023.
*/
Type
  implemented-floats // ~> floats(implemented-floats-format)
Funcon
  implemented-floats-format : =>float-formats
   ~> binary64
Funcon
  implemented-float-literal(FL:strings) : =>implemented-floats

### Characters
/*
  Character values are represented as 8-bit integers between 0 and 255.
  Character codes between 0 and 127 are interpreted following the ASCII
  standard. The current implementation interprets character codes between 
  128 and 255 following the ISO 8859-1 standard.
*/
Type
  implemented-characters <: characters
Type
  implemented-character-points
   ~> bounded-integers(0,255)
Funcon
  implemented-character(C:characters) : =>implemented-characters?
   ~> ascii-character[C] // FIX-ME: allow ISO-Latin-1

### Character strings
/*
  String values are finite sequences of characters. The current implementation
  supports strings containing up to 2^24 - 5 characters (16777211 characters);
  (...)
*/
Type
  implemented-strings <: lists(implemented-characters)
Funcon
  implemented-string(L:lists(implemented-characters)) : =>implemented-strings?
    ~> when-true(is-less-or-equal(length list-elements L, 16777211), L)


## Tuples
/*
  Tuples of values are written (v_1, ..., v_n), standing for the n-tuple of
  values v_1 to v_n. The current implementation supports tuples of up to 
  2^22 - 1 elements (4194303 elements).
*/
Type
  implemented-tuples <: tuples(implemented-values*)
   ~> tuples(values*) // FIX-ME: remove
Funcon
  implemented-tuple(T:tuples(values*)) : =>implemented-tuples?
    ~> when-true(is-less-or-equal(length tuple-elements T, 4194303), T)

/*
  In OCaml Light, the unit value is represented by `tuple( )`.
*/

/*
  In OCaml Light, lists are written [v_1; ...; v_n], and their values are
  represented by list values in CBS.
*/
Type
  implemented-lists <: lists(implemented-values)
   ~> lists(values) // FIX-ME: remove
Funcon
  implemented-list(L:lists(values)) : =>implemented-lists?
    ~> when-true(is-less-or-equal(length list-elements L, 4194303), L)


## Records
/*
  Record values are labeled tuples of values. The record value written 
  { field_1 = v_1; ...; field_n = v_n } associates the value v_i to the
  record field field_i, for i = 1 ... n. The current implementation supports
  records with up to 2^22 - 1 fields (4194303 fields).
*/
Type
  implemented-records <: records(implemented-values)
   ~> records(values) // FIX-ME: remove
Funcon
  implemented-record(R:records(implemented-values)) : =>implemented-records?
    ~> when-true(is-less-or-equal(length map-elements record-map R, 4194303), R)

/*
  In OCaml Light, records are non-mutable, and references are represented by
  mutable variables.
*/
Type
  implemented-references ~> variables
  

## Arrays
/*
  Arrays are finite, variable-sized sequences of values of the same type. 
  The current implementation supports arrays containing up to 2^22 - 1 elements
  (4194303 elements) unless the elements are floating-point numbers (2097151
  elements in this case); (...)
*/
Type
  implemented-vectors <: vectors(implemented-values)
   ~> vectors(values) // FIX-ME: remove
Funcon
  implemented-vector(V:vectors(implemented-values)) : =>implemented-vectors?
    ~> when-true(is-less-or-equal(length map-elements record-map V, 4194303),V)
// FIX ME: I think the use of "record-map" here might be an error

## Variant values
/*
  Variant values are either a constant constructor, or a pair of a non-constant
  constructor and a value. The former case is written constr; the latter case
  is written (v1, ..., vn), where the vi are said to be the arguments of the 
  non-constant constructor constr. The parentheses may be omitted if there is
  only one argument. (...) The current implementation limits each variant type
  to have at most 246 non-constant constructors and 2^30-1 constant constructors.
*/

Type
  implemented-variants <: variants(implemented-values)
   ~> variants(values) // FIX-ME: remove
Funcon
  implemented-variant(V:variants(implemented-values)) : =>implemented-variants
    ~> V


## Functions
/*
  Functional values are mappings from values to values.
*/

Type
  implemented-functions <: functions(implemented-values, implemented-values)
   ~> functions(values, values) // FIX-ME: remove
Funcon
  implemented-function(F:functions(implemented-values, implemented-values)) : 
                                                       =>implemented-functions
    ~> F
# Computations

## Normal computation

### Flowing
[
  Funcon   sequential      Alias seq
  Funcon   effect
  Funcon   if-true-else    Alias if-else
  Funcon   while-true      Alias while
]

### Giving
[
  Funcon   initialise-giving
  Funcon   give
  Funcon   given
  Funcon   left-to-right-map
  Funcon   interleave-map
]

### Binding
[
  Type     environments       Alias envs
  Datatype identifiers        Alias ids
  Funcon   initialise-binding
  Funcon   bound-value        Alias bound
  Funcon   scope
  Funcon   accumulate
  Funcon   collateral
  Funcon   recursive
]

### Storing
[
  Funcon   initialise-storing
  Datatype variables                     Alias vars
  Funcon   allocate-initialised-variable Alias alloc-init
  Funcon   assign
  Funcon   assigned
  Funcon   structural-assigned           Alias current-value
]

### Interacting

#### Input
[
  Funcon   read
]

#### Output
[
  Funcon   print
]

## Abnormal computation

### Failing
[
  Funcon   finalise-failing
  Funcon   fail
  Funcon   else
  Funcon   checked
]

### Throwing
[
  Funcon   finalise-throwing
  Funcon   throw
  Funcon   handle-thrown
]

# Values

## Value Types
[
  Type   values           Alias vals
  Funcon is-in-type       Alias is
  Funcon when-true        Alias when
  Type   ground-values    Alias ground-vals
  Funcon is-equal         Alias is-eq
]

## Primitive values

### Booleans
[
  Datatype booleans      Alias bools
  Funcon   true
  Funcon   false
  Funcon   not
  Funcon   and
  Funcon   or
]

### Integers
[
  Type     integers                     Alias ints
  Type     bounded-integers             Alias bounded-ints
  Type     natural-numbers              Alias nats
  Funcon   natural-successor            Alias nat-succ
  Funcon   integer-add                  Alias int-add
  Funcon   integer-subtract             Alias int-sub
  Funcon   integer-multiply             Alias int-mul
  Funcon   integer-divide               Alias int-div
  Funcon   integer-modulo               Alias int-mod
  Funcon   integer-absolute-value       Alias int-abs
  Funcon   integer-negate               Alias int-neg
  Funcon   integer-is-less              Alias is-less
  Funcon   integer-is-less-or-equal     Alias is-less-or-equal
  Funcon   integer-is-greater           Alias is-greater
  Funcon   integer-is-greater-or-equal  Alias is-greater-or-equal
  Funcon   decimal-natural              Alias decimal
  Funcon   integer-sequence
]

### Floats
[
  Datatype float-formats
  Funcon   binary64
  Type     floats
  Funcon   float-negate
  Funcon   float-absolute-value
  Funcon   float-add
  Funcon   float-subtract
  Funcon   float-multiply
  Funcon   float-divide
  Funcon   float-remainder
  Funcon   float-sqrt
  Funcon   float-float-power
  Funcon   float-floor
  Funcon   float-ceiling
  Funcon   float-truncate
  Funcon   float-log
  Funcon   float-log10
  Funcon   float-exp
  Funcon   float-sin
  Funcon   float-cos
  Funcon   float-tan
  Funcon   float-asin
  Funcon   float-acos
  Funcon   float-atan
  Funcon   float-sinh
  Funcon   float-cosh
  Funcon   float-tanh
  Funcon   float-atan2
]

### Characters
[
  Type     characters                          Alias chars
  Funcon   unicode-character                   Alias char
  Funcon   backspace
  Funcon   horizontal-tab
  Funcon   line-feed
  Funcon   carriage-return
  Funcon   backslash
]

### The null value

[
  Datatype null-type
  Funcon   null-value Alias null
]

## Composite values

### Sequences of values
[
  Funcon   length
  Funcon   index
  Funcon   reverse
  Funcon   n-of
  Funcon   intersperse
]

### Tuples
[
  Datatype tuples
  Funcon   tuple-elements
]

### Lists
[
  Datatype lists
  Funcon   list
  Funcon   list-elements
  Funcon   list-nil       Alias nil
  Funcon   list-cons      Alias cons
  Funcon   list-head      Alias head
  Funcon   list-tail      Alias tail
  Funcon   list-length
  Funcon   list-append
]

### Strings
[
  Type     strings
  Funcon   string-append
  Funcon   to-string
]

### Vectors
[
  Datatype vectors
  Funcon   vector
  Funcon   vector-elements
]

### Bits and bit vectors
[
  Datatype bit-vectors
  Funcon   bit-vector-not
  Funcon   bit-vector-and
  Funcon   bit-vector-or
  Funcon   bit-vector-xor
  Funcon   bit-vector-shift-left
  Funcon   bit-vector-logical-shift-right
  Funcon   bit-vector-arithmetic-shift-right
  Funcon   integer-to-bit-vector
  Funcon   bit-vector-to-integer
  Funcon   signed-bit-vector-maximum
  Funcon   signed-bit-vector-minimum
]

### Sets
[
  Funcon   set
  Funcon   set-elements
  Funcon   is-in-set
]

### Maps
[
  Type     maps
  Funcon   map
  Funcon   map-elements
  Funcon   map-lookup    Alias lookup
  Funcon   map-domain    Alias dom
  Funcon   map-override
  Funcon   map-unite
]

### Records
[
  Datatype records
  Funcon   record
  Funcon   record-map
  Funcon   record-select
]

### Variants
[
  Datatype variants
  Funcon   variant
]

## Abstraction values

### Generic abstractions
[
  Funcon   abstraction
  Funcon   closure
]

### Functions
[
  Datatype functions
  Funcon   function
  Funcon   apply
  Funcon   curry
]

### Patterns
[
  Datatype patterns
  Funcon   pattern
  Funcon   pattern-any
  Funcon   pattern-bind
  Funcon   pattern-else
  Funcon   pattern-unite
  Funcon   match
  Funcon   match-loosely
  Funcon   case-match
]

#3 Names

## Naming objects

Syntax
  VN : value-name
  ::= lowercase-ident  
 	| '(' operator-name ')'
  
  ON : operator-name ::= prefix-op | infix-op  
  
  PO : prefix-op ::= prefix-symbol // added
 
//  infix-op
//  ::= infix-symbol 
//    | '*' | '+' | '-' | '-.' | '=' | '<' | '>' | '||' | '&' | '&&' 
// 	  | '!=' | 'or' | ':=' | 'mod' 
// 	  | 'land' | 'lor' | 'lxor' | 'lsl' | 'lsr' | 'asr'  

### Infix operator precedence

Syntax
  IO : infix-op
  ::= infix-op-1 | infix-op-2 | infix-op-3 | infix-op-4
	| infix-op-5 | infix-op-6 | infix-op-7 | infix-op-8
Lexis
  IO-1 : infix-op-1
  ::= '**' operator-char* | 'lsl' | 'lsr' | 'asr'
  
  IO-2 : infix-op-2
  ::= '*'
    | '*' operator-char-not-asterisk operator-char*
    | ( '/' | '%' ) operator-char*
    | 'mod' | 'land' | 'lor' | 'lxor' 
  
  IO-3 : infix-op-3
  ::= ( '+' | '-' ) operator-char*
  
  IO-4 : infix-op-4
  ::= ( '@' | '^' ) operator-char*
  
  IO-5 : infix-op-5
  ::= ( '=' | '<' | '>' | '$' ) operator-char*
    | '|' ( operator-char-not-bar operator-char* )?
    | '||' operator-char+
    | '&' operator-char-not-ampersand operator-char*
    | '&&' operator-char+
    | '!='
  
  IO-6 : infix-op-6
  ::= '&' | '&&'
  
  IO-7 : infix-op-7
  ::= 'or' | '||'
  
  IO-8 : infix-op-8
  ::= ':='
  
Lexis
  CN :  constr-name     ::= capitalized-ident  
 
  TCN : typeconstr-name ::= lowercase-ident  
 
  FN :  field-name      ::= lowercase-ident  

  MN :  module-name     ::= capitalized-ident  


## Referring to named objects

Syntax
  VP :    value-path ::= value-name
 
  CSTR :  constr     ::= constr-name  
 
  TCSTR : typeconstr ::= typeconstr-name  
 
  F :     field      ::= field-name  


Semantics
  value-name[[ _:value-path ]] : =>ids
Rule
  value-name[[ LI ]] = \"LI\"
Rule
  value-name[[ '(' PS ')' ]] = string-append("(", \"PS\", ")")
Rule
  value-name[[ '(' IO-1 ')' ]] = string-append("(", \"IO-1\", ")")
Rule
  value-name[[ '(' IO-2 ')' ]] = string-append("(", \"IO-2\", ")")
Rule
  value-name[[ '(' IO-3 ')' ]] = string-append("(", \"IO-3\", ")")
Rule
  value-name[[ '(' IO-4 ')' ]] = string-append("(", \"IO-4\", ")")
Rule
  value-name[[ '(' IO-5 ')' ]] = string-append("(", \"IO-5\", ")")
Rule
  value-name[[ '(' IO-6 ')' ]] = string-append("(", \"IO-6\", ")")
Rule
  value-name[[ '(' IO-7 ')' ]] = string-append("(", \"IO-7\", ")")
Rule
  value-name[[ '(' IO-8 ')' ]] = string-append("(", \"IO-8\", ")")

Semantics
  constr-name[[ _:constr ]] : =>ids
Rule
  constr-name[[ CN ]] = \"CN\"

Semantics
  typeconstr-name[[ _:typeconstr ]] : =>ids
Rule
  typeconstr-name[[ TCN ]] = \"TCN\"

Semantics
  field-name[[ _:field ]] : =>ids 
Rule
  field-name[[ FN ]] = \"FN\"

#5 Constants

Syntax
  CNST : constant 
  ::= integer-literal 
    | float-literal 
    | char-literal 
    | string-literal 
    | constr
    | 'false'  
    | 'true'  
    | '(' ')'  
    | 'begin' 'end'  
    | '[' ']'  
    | '[|' '|]'  

Semantics
  value[[ _:constant ]] : =>implemented-values
Rule
  value[[ IL ]] = integer-value[[ IL ]]
Rule
  value[[ FL ]] = float-value[[ FL ]]
Rule
  value[[ CL ]] = character-value[[ CL ]]
Rule
  value[[ SL ]] = string-value[[ SL ]]
Rule
  value[[ CSTR ]] = bound(constr-name[[ CSTR ]])
Rule
  value[[ 'false' ]] = false
Rule
  value[[ 'true' ]] = true
Rule
  value[[ '(' ')' ]] = null
Rule
  value[[ 'begin' 'end' ]] = null
Rule
  value[[ '[' ']' ]] = nil
Rule
  value[[ '[|' '|]' ]] = vector( )
  
#12 Core library

[
Funcon ocaml-light-core-library
Funcon ocaml-light-match-failure
Funcon ocaml-light-is-structurally-equal
Funcon ocaml-light-to-string
Funcon ocaml-light-define-and-display
Funcon ocaml-light-evaluate-and-display
]

Meta-variables
  R, S, S1, S2, S3, T, U <: values
  S* <: values*
  T+ <: values+

## Abbreviations

/*
  The following funcons take computations `X` and return (curried) functions.
  `X` refers to a single function argument as `arg`, or to individual arguments
  of a curried function of several arguments as `arg-1`, `arg-2`, `arg-3`.
*/
Auxiliary Funcon
  op-1(X:S=>T) : =>functions(S,T)
    ~> function abstraction X
Auxiliary Funcon
  op-2(X:tuples(S1,S2)=>T) : =>functions(S1, functions(S2,T))
    ~> curry function abstraction X
Auxiliary Funcon
  op-3(X:tuples(S1,S2,S3)=>T) : =>functions(S1, functions(S2, functions(S3, T)))
   ~> function abstraction(
        curry partial-apply-first(function abstraction X, given))

Auxiliary Funcon
  partial-apply-first(F:functions(tuples(R,S,T+),U), V:R) :
    =>functions(tuples(S,T+),U)
    ~> function abstraction(apply(F, tuple(V, tuple-elements given)))
/*
  `partial-apply-first(F, V)` provides `V` as the first argument to a function
  expecting a tuple of 3 or more arguments, returning a function expecting
  a tuple of one fewer arguments.
*/

Auxiliary Funcon
  arg : T=>T
    ~> given
Auxiliary Funcon
  arg-1 : tuples(S1,S*)=>S1
    ~> checked index(1, tuple-elements given)
Auxiliary Funcon
  arg-2 : tuples(S1,S2,S*)=>S2
    ~> checked index(2, tuple-elements given)
Auxiliary Funcon
  arg-3 : tuples(S1,S2,S3,S*)=>S3
    ~> checked index(3, tuple-elements given)


## Library

/*
  The `ocaml-light-core-library` environment maps most of the names defined
  in OCaml Module Pervasives (the initially opened module) to funcon terms.
  See [https://caml.inria.fr/pub/docs/manual-ocaml-4.06/core.html] for further
  details and comments.
  
  It also maps some other names defined in the OCaml Standard Libarary to
  funcon terms (to support tests using them without opening those modules).
*/


Funcon
  ocaml-light-core-library : =>environments 
   ~>
   {// Predefined exceptions
    "Match_failure" |->
	  op-1(variant("Match_failure", arg)),
    "Invalid_argument" |->
	  op-1(variant("Invalid_argument", arg)),
    "Division_by_zero" |->
	  variant("Division_by_zero", tuple( )),

	// Exceptions	
	"raise" |->
	  op-1(throw(arg)),

    //Comparisons
    "(=)" |->
	  op-2(ocaml-light-is-structurally-equal(arg-1, arg-2)),
	"(<>)" |->
	  op-2(not(ocaml-light-is-structurally-equal(arg-1, arg-2))),
	"(<)" |->
	  op-2(is-less(arg-1, arg-2)),
	"(>)" |->
	  op-2(is-greater(arg-1, arg-2)),
	"(<=)" |->
	  op-2(is-less-or-equal(arg-1, arg-2)),
	"(>=)" |->
	  op-2(is-greater-or-equal(arg-1, arg-2)),
	"min" |->
	  op-2(if-true-else(is-less(arg-1, arg-2), arg-1, arg-2)),
	"max" |->
	  op-2(if-true-else(is-greater(arg-1, arg-2), arg-1, arg-2)),
    "(==)" |->
	  op-2(if-true-else(
	    and(is-in-type(arg-1, ground-values), is-in-type(arg-2, ground-values)),
		is-equal(arg-1, arg-2),
		throw(variant("Invalid_argument", "equal: functional value")))),
    "(!=)" |->
	  op-2(if-true-else(
	    and(is-in-type(arg-1, ground-values), is-in-type(arg-2, ground-values)),
		not is-equal(arg-1, arg-2),
		throw(variant("Invalid_argument", "equal: functional value")))),
 
    // Boolean operations (excluding lazy conditionals)
    "not" |->
	  op-1(not(arg)),

    // Integer arithmetic
    "(~-)" |->
	  op-1(implemented-integer integer-negate(arg)),
    "(~+)" |->
	  op-1(implemented-integer arg),
	"succ" |->
	  op-1(implemented-integer integer-add(arg, 1)),
	"pred" |->
	  op-1(implemented-integer integer-subtract(arg, 1)),
	"(+)" |->
	  op-2(implemented-integer integer-add(arg-1, arg-2)),
	"(-)" |->
	  op-2(implemented-integer integer-subtract(arg-1, arg-2)),
	"(*)" |->
	  op-2(implemented-integer integer-multiply(arg-1, arg-2)),
	"(/)" |->
	  op-2(implemented-integer if-true-else(is-equal(arg-2, 0),
					throw(variant("Division_by_zero", tuple( ))),
					checked integer-divide(arg-1, arg-2))),
	"(mod)" |->
	  op-2(implemented-integer checked integer-modulo(arg-1, arg-2)),
 	"abs" |->
	  op-1(implemented-integer integer-absolute-value(arg)),
	"max_int" |->
	  op-1(signed-bit-vector-maximum(implemented-integers-width)),
	"min_int" |->
	  op-1(signed-bit-vector-minimum(implemented-integers-width)),

    // Bitwise operations
	"(land)" |->
	  op-2(bit-vector-to-integer
	    bit-vector-and(implemented-bit-vector arg-1, 
	      implemented-bit-vector arg-2)),
	"(lor)" |->
	  op-2(bit-vector-to-integer
	    bit-vector-or(implemented-bit-vector arg-1, 
	      implemented-bit-vector arg-2)),
	"(lxor)" |->
	  op-2(bit-vector-to-integer
	    bit-vector-xor(implemented-bit-vector arg-1, 
	      implemented-bit-vector arg-2)),
	"lnot" |->
	  op-1(bit-vector-to-integer
	    bit-vector-not(implemented-bit-vector arg)),
	"(lsl)" |->
	  op-2(bit-vector-to-integer
        bit-vector-shift-left(implemented-bit-vector arg-1, arg-2)),
	"(lsr)" |->
	  op-2(bit-vector-to-integer
        bit-vector-logical-shift-right(implemented-bit-vector arg-1, arg-2)),
	"(asr)" |->
	  op-2(bit-vector-to-integer
        bit-vector-arithmetic-shift-right(implemented-bit-vector arg-1, arg-2)),

	// Floating-point arithmetic
	"(~-.)" |->
	  op-1(float-negate(implemented-floats-format, arg)),
	"(~+.)" |->
	  op-1(arg),
	"(+.)" |->
	  op-2(float-add(implemented-floats-format, arg-1, arg-2)),
	"(-.)" |->
	  op-2(float-subtract(implemented-floats-format, arg-1, arg-2)),
	"(*.)" |->
	  op-2(float-multiply(implemented-floats-format, arg-1, arg-2)),
	"(/.)" |->
	  op-2(float-divide(implemented-floats-format, arg-1, arg-2)),
	"(**)" |->
	  op-2(float-float-power(implemented-floats-format, arg-1, arg-2)),
	"sqrt" |->
	  op-1(float-sqrt(implemented-floats-format, arg)),
	"exp" |->
	  op-1(float-exp(implemented-floats-format, arg)),
	"log" |->
	  op-1(float-log(implemented-floats-format, arg)),
	"log10" |->
	  op-1(float-log10(implemented-floats-format, arg)),
	"cos" |->
	  op-1(float-cos(implemented-floats-format, arg)),
	"sin" |->
	  op-1(float-sin(implemented-floats-format, arg)),
	"tan" |->
	  op-1(float-tan(implemented-floats-format, arg)),
	"acos" |->
	  op-1(float-acos(implemented-floats-format, arg)),
	"asin" |->
	  op-1(float-asin(implemented-floats-format, arg)),
	"atan" |->
	  op-1(float-atan(implemented-floats-format, arg)),
	"atan2" |->
	  op-2(float-atan2(implemented-floats-format, arg-1, arg-2)),
	"cosh" |->
	  op-1(float-cosh(implemented-floats-format, arg)),
	"sinh" |->
	  op-1(float-sinh(implemented-floats-format, arg)),
	"tanh" |->
	  op-1(float-tanh(implemented-floats-format, arg)),
	"ceil" |->
	  op-1(implemented-integer float-ceiling(implemented-floats-format, arg)),
    "floor" |->
	  op-1(implemented-integer float-floor(implemented-floats-format, arg)),
	"abs_float" |->
	  op-1(float-absolute-value(implemented-floats-format, arg)),
	"mod_float" |->
	  op-2(float-remainder(implemented-floats-format, arg-1, arg-2)),
	"int_of_float" |->
	  op-1(implemented-integer float-truncate(implemented-floats-format, arg)),
	"float_of_int" |->
	  op-1(implemented-float-literal(string-append(to-string(arg), ".0"))),

    // String operations
	"(^)" |->
	  op-2(string-append(arg-1, arg-2)),

	// String conversion operations
	"string_of_int" |->
	  op-1(to-string(arg)),
	"int_of_string" |->
	  op-1(implemented-integer implemented-integer-literal(arg)),
	"string_of_float" |->
	  op-1(to-string(arg)),
    "float_of_string" |->
	  op-1(implemented-float-literal(arg)),	

	// List operations
	"(@)" |->
	  op-2(list-append(arg-1, arg-2)),

	// Input/output
	//   Output functions on standard output
    "print_char" |->
	  op-1(print(to-string(arg))),
	"print_string" |->
	  op-1(print(arg)),
    "print_int" |->
	  op-1(print(to-string(arg))),
 	"print_float" |->
	  op-1(print(to-string(arg))),
	"print_newline" |->
	  op-1(print "\n"),
	//   Input functions on standard input
    "read_line" |->
	  op-1(read),
    "read_int" |->
	  op-1(implemented-integer-literal(read)),
    "read_float" |->
	  op-1(implemented-float-literal(read)),

    // References (not represented as mutable records)
	"ref" |->
	  op-1(allocate-initialised-variable(implemented-values, arg)),
	"(!)" |->
	  op-1(assigned(arg)),
	"(:=)" |->
	  op-2(assign(arg-1, arg-2)),

    // Module List
	"length" |->
	  op-1(implemented-integer list-length(arg)),
	"cons" |->
	  op-2(cons(arg-1, arg-2)),
	"hd" |->
	  op-1(else(head(arg), throw(variant("Failure", "hd")))),
	"tl" |->
	  op-1(else(tail(arg), throw(variant("Failure", "tl")))),
	"rev" |->
	  op-1(list(reverse(list-elements(arg)))),
	
	// Module Array
	"array_length" |->
	  op-1(implemented-integer length(vector-elements(arg))),
	"array_make" |->
	  op-2(if-true-else(is-greater-or-equal(arg-1, 0),
			 vector(interleave-map(
			   allocate-initialised-variable(values, arg),
			   n-of(arg-1, arg-2))),
			 throw(variant("Invalid_argument", "array_make")))),
    "array_append" |->
	  op-2(vector(vector-elements(arg-1), vector-elements(arg-2))),
    "array_get" |->
	  op-2(else(assigned(checked index(nat-succ arg-2, vector-elements(arg-1))),
    			throw(variant("Invalid_argument", "array_get")))),
    "array_set" |->
	  op-3(else(assign(checked index(nat-succ arg-2, vector-elements(arg-1)), arg-3),
				throw(variant("Invalid_argument", "array_set"))))
   }


## Language-specific funcons

### Exception values

Funcon
  ocaml-light-match-failure : =>variants(M)
    ~> variant("Match_failure", tuple("", 0, 0))
/*
  `ocaml-light-match-failure` gives a value to be thrown when a match fails.
  The variant value should consist of the source program text, line, and column,
  but these are currently not included in the translation of OCaml Light.
*/

### Structural equality

Funcon
  ocaml-light-is-structurally-equal(_:implemented-values, _:implemented-values) : 
                                                                       =>booleans
/*
  `ocaml-light-is-structurally-equal(V1, V2)` is false whenever `V1` or `V2` contains a
  function. For vectors, it compares all their respective assigned values.
  It is equality on primitive values, and defined inductively on composite values.
*/

// Unit Type
Rule
  ocaml-light-is-structurally-equal(null-value, null-value) ~> true
// Booleans
Rule
  ocaml-light-is-structurally-equal(B1:booleans, B2:booleans) ~> is-equal(B1,B2)
// Integers
Rule
  ocaml-light-is-structurally-equal(I1:implemented-integers, I2:implemented-integers) ~>
  	is-equal(I1,I2)
// Floats
Rule
  ocaml-light-is-structurally-equal(F1:implemented-floats, F2:implemented-floats) ~>
  	is-equal(F1,F2)
// Characters
Rule
  ocaml-light-is-structurally-equal(C1:implemented-characters, C2:implemented-characters) ~>
  	is-equal(C1,C2)
// Strings
Rule
  ocaml-light-is-structurally-equal(S1:implemented-strings, S2:implemented-strings) ~>
  	is-equal(S1,S2)
// Tuples
Rule
  ocaml-light-is-structurally-equal(tuple(), tuple()) ~> true
Rule
  ocaml-light-is-structurally-equal(tuple(), tuple(V+)) ~> false
Rule
  ocaml-light-is-structurally-equal(tuple(V+), tuple()) ~> false
Rule
  ocaml-light-is-structurally-equal(tuple(V, V*), tuple(W, W*)) ~>
  	and(ocaml-light-is-structurally-equal(V, W), ocaml-light-is-structurally-equal(tuple(V*), tuple(W*)))
// Lists
Rule
  ocaml-light-is-structurally-equal([], []) ~> true
Rule
  ocaml-light-is-structurally-equal([], [V+]) ~> false
Rule
  ocaml-light-is-structurally-equal([V+], []) ~> false
Rule
  ocaml-light-is-structurally-equal([V,V*], [W,W*]) ~>
  	and(ocaml-light-is-structurally-equal(V,W), ocaml-light-is-structurally-equal([V*], [W*]))
// Records
Rule
                       dom(Map1) == dom(Map2)
  ----------------------------------------------------------------------
  ocaml-light-is-structurally-equal(record(Map1:maps(_,_)), record(Map2:maps(_,_)))
    ~> not(is-in-set(false, 
         set(interleave-map(
           ocaml-light-is-structurally-equal(
             checked lookup(Map1, given), 
             checked lookup(Map2, given)),
           set-elements(dom(Map1))))))
// References
Rule
  ocaml-light-is-structurally-equal(V1:variables, V2:variables) ~>
  	ocaml-light-is-structurally-equal(assigned(V1), assigned(V2))
// Vectors
Rule
  ocaml-light-is-structurally-equal(Vec1:vectors(values), Vec2:vectors(values)) ~>
  	ocaml-light-is-structurally-equal([vector-elements(Vec1)], [vector-elements(Vec2)])
// Variants
Rule
  ocaml-light-is-structurally-equal(variant(Con1,V1), variant(Con2,V2)) ~>
  	if-true-else(
  	  is-equal(Con1, Con2),
  	  if-true-else(
  	  	or(is-equal(tuple( ), V1), is-equal(tuple( ), V2)),
  	  	and(is-equal(tuple( ), V1), is-equal(tuple( ), V2)),
  	  	ocaml-light-is-structurally-equal(V1, V2)),
  	  false)
// Functions
Rule
  ocaml-light-is-structurally-equal(_:functions(_,_), _:functions(_,_)) ~>
  	throw(variant("Invalid_argument", "equal: functional value"))

### Console display

Funcon
  ocaml-light-to-string(_:values) : =>strings
/*
  `ocaml-light-to-string(V)` gives the string represention of OCaml Light values
  as implemented by the ocaml interpreter.
*/

Rule // Unit
  ocaml-light-to-string(null-value) ~> "()"
Rule // Booleans
  ocaml-light-to-string(B:booleans) ~> to-string(B)
Rule // Integers
  ocaml-light-to-string(I:integers) ~> to-string(I)
Rule // Floats
  ocaml-light-to-string(F:implemented-floats) ~> to-string(F)
Rule // Characters
  ocaml-light-to-string(C:implemented-characters) ~>
  	string-append("'", to-string(C), "'")
Rule // Strings
  S =/= []
  ----------------------------------------------------------------
  ocaml-light-to-string(S:implemented-strings) ~> string-append("\"", S, "\"")
Rule // Functions
  ocaml-light-to-string(_:functions(_,_)) ~> "<fun>"
Rule // References
  ocaml-light-to-string(V:variables) ~>
  	string-append("ref ", ocaml-light-to-string(assigned(V)))
Rule // Variants
  ocaml-light-to-string(variant(Con,Arg)) ~>
  	if-true-else(is-equal(tuple( ),Arg), Con,
  	  string-append(Con, " ", ocaml-light-to-string(Arg)))
Rule // Tuples
  ocaml-light-to-string(tuple(V:values, V+:values+)) ~>
  	string-append(
  	  "(",
  	  intersperse(", ", interleave-map(ocaml-light-to-string(given), V, V+)),
  	  ")")
Rule // Lists
  ocaml-light-to-string([V*:values*]) ~>
  	string-append(
  	  "[",
  	  intersperse("; ", interleave-map(ocaml-light-to-string(given), V*)),
  	  "]")
Rule // Vectors
  ocaml-light-to-string(V:implemented-vectors) ~>
  	string-append(
  	  "[|",
  	  intersperse("; ", interleave-map(ocaml-light-to-string(given), 
  	    vector-elements(current-value(V)))),
  	  "|]")
Rule // Records
  ocaml-light-to-string(record(M:maps(_,_))) ~>
  	string-append(
  	  "{",
  	  intersperse("; ", interleave-map(
  	        string-append(arg-1," = ",ocaml-light-to-string(arg-2)),
  	        map-elements(M))),
  	  "}")

Funcon
  ocaml-light-define-and-display(Env:envs) : =>envs
   ~> sequential(
        effect left-to-right-map(
          print(arg-1, " = ", ocaml-light-to-string arg-2, "\n"),
          map-elements Env), 
        Env)

Funcon
  ocaml-light-evaluate-and-display(V:implemented-values) : =>envs
   ~> sequential(
        print("- = ", ocaml-light-to-string V, "\n"), 
        map())

#9 Classes


#4 Type expressions

Syntax
  T : typexpr
  ::= '\'' ident
	| '_'
	| '(' typexpr ')'
	| typexpr '->' typexpr
	| typexpr star-typexpr+
	| typeconstr
	| typexpr typeconstr
	| '(' typexpr comma-typexpr+ ')' typeconstr

  ST : star-typexpr ::= '*' typexpr

  CT : comma-typexpr ::= ',' typexpr

  PT : poly-typexpr 
  ::= typexpr  
    | ( '\'' ident )+ '.' typexpr 

### Interacting

#### Output

[
  Entity standard-out
  Funcon print
]

Entity
  _ -- standard-out!(V*:values*) -> _
/*
  This entity represents the sequence of values output by a particular
  transition, where the empty sequence `( )` represents the lack of output.
  Composition of transitions concatenates their output sequences.
*/

Funcon
  print(V*:values*) : =>null-type
/*
  `print(X*)` evaluates the arguments `X*` and emits the resulting sequence of
  values on the standard-out channel. `print( )` has no effect.
*/
Rule
  print(V*:values*) -- standard-out!(V*) -> null-value


#### Input

[
  Entity standard-in
  Funcon read
]

Entity
  _ -- standard-in?(V*:values*) -> _
/*
  This entity represents the sequence of values input by a particular
  transition, where the empty sequence `( )` represents that no values are
  input. The value `null-value` represents the end of the input.
  
  Composition of transitions concatenates their input sequences, except that
  when the first sequence ends with `null-value`, the second seqeunce has to be
  just `null-value`.
*/

Funcon
  read : =>values
/*
  `read` inputs a single value from the standard-in channel, and returns it.
  If the end of the input has been reached, `read` fails.
*/

Rule
  read -- standard-in?(V:~null-type) -> V
Rule
  read -- standard-in?(null-value) -> fail
### Storing

[
  Datatype locations                     Alias locs
  Type     stores
  Entity   store
  Funcon   initialise-storing
  Funcon   store-clear
  Datatype variables                     Alias vars
  Funcon   variable                      Alias var
  Funcon   allocate-variable             Alias alloc
  Funcon   recycle-variables             Alias recycle
  Funcon   initialise-variable           Alias init
  Funcon   allocate-initialised-variable Alias alloc-init
  Funcon   assign
  Funcon   assigned
  Funcon   un-assign
  Funcon   structural-assign
  Funcon   structural-assigned
]

Meta-variables
  T, T' <: values


#### Stores

Type
  locations ~> atoms
Alias
  locs = locations
/*
  A storage location is represented by an atom.
*/
 
Type
  stores ~> maps(locations, values?)
/*
  The domain of a store is the set of currently allocated locations.
  Mapping a location to `( )` models the absence of its stored value;
  removing it from the store allows it to be re-allocated.
*/

Entity
  < _ , store(Sigma:stores) > ---> < _ , store(Sigma':stores) >
/*
  The current store is a mutable entity.
  A transition ``< X , store(Sigma) > ---> < X' , store(Sigma') >`` models
  a step from `X` to `X'` where the difference between `Sigma` and `Sigma'`
  (if any) corresponds to storage effects.
*/

Funcon
  store-clear : =>null-type
Rule
  < store-clear , store(_) > ---> < null-value , store(map( )) >
/*
  `store-clear` ensures the store is empty.
*/

Funcon 
  initialise-storing(X:=>T) : =>T
   ~> sequential(store-clear, 
        initialise-giving(initialise-generating(X)))
Alias
  init-storing = initialise-storing
/*
  `initialise-storing(X)` ensures that the entities used by the funcons for
  storing are properly initialised.
*/

#### Simple variables

/*  
  Simple variables may store primitive or structured values. The type of
  values stored by a variable is fixed when it is allocated. For instance,
  `allocate-variable(integers)` allocates a simple integer variable, and
  `allocate-variable(vectors(integers))` allocates a structured variable for
  storing vectors of integers, which can be updated only monolithically.
*/

Datatype
variables ::= variable(L:locations, T:value-types)
Alias
  vars = variables
Alias
  var = variable
/*
  `variables` is the type of simple variables that can store values of
  a particular type.

  `variable(L, T)` constructs a simple variable for storing values of
  type `T` at location `L`. Variables at different locations are independent. 
*/

Funcon
  allocate-variable(T) : =>variables
Alias
  alloc = allocate-variable
/*
  `allocate-variable(T)` gives a simple variable whose location is not in the
  current store. Subsequent uses of `allocate-variable(T')` give independent
  variables, except after `recycle-variables(V,...)` or `store-clear`.
*/
Rule
  < use-atom-not-in(dom(Sigma)) , store(Sigma) > ---> < L , store(Sigma') >
  map-override({L |-> ( )}, Sigma') ~> Sigma''
  -------------------------------------------------------------------------
  < allocate-variable(T:types) , store(Sigma) >
    ---> < variable(L, T) , store(Sigma'') >

Funcon
  recycle-variables(Var+:variables+) : =>null-type
Alias
  recycle = recycle-variables
/*
  `recycle-variables(Var,...)` removes the locations of `Var`, ..., from the
  current store, so that they may subsequently be re-allocated.
*/
Rule
  is-in-set(L, dom(Sigma)) == true
  ---------------------------------------------------------------------
  < recycle-variables(variable(L:locations, T:types)) , store(Sigma) >
    ---> < null-value , store(map-delete(Sigma, {L})) >
Rule
  is-in-set(L, dom(Sigma)) == false
  ---------------------------------------------------------------------
  < recycle-variables(variable(L:locations, T:types)) , store(Sigma) >
    ---> < fail , store(Sigma) >
Rule
  recycle-variables(Var:variables, Var+:variables+)
    ~> sequential(recycle-variables(Var), recycle-variables(Var+))

Funcon
  initialise-variable(_:variables, _:values) : =>null-type
Alias
  init = initialise-variable
/*
  `initialise-variable(Var, Val)` assigns `Val` as the initial value of `Var`,
  and gives `null-value`. If `Var` already has an assigned value, it fails.
*/
Rule
  and(is-in-set(L, dom(Sigma)),
      not is-value(map-lookup(Sigma, L)),
      is-in-type(Val, T)) 
    == true
  ----------------------------------------------------------------------------
  < initialise-variable(variable(L:locations, T:types), Val:values) , 
    store(Sigma) > ---> < null-value , store(map-override({L|->Val}, Sigma)) >
Rule
  and(is-in-set(L, dom(Sigma)),
      not is-value(map-lookup(Sigma, L)),
      is-in-type(Val, T)) 
    == false
  ----------------------------------------------------------------------------
  < initialise-variable(variable(L:locations, T:types), Val:values) , 
    store(Sigma) > ---> < fail , store(Sigma) >

Funcon
  allocate-initialised-variable(T, Val:T) : =>variables
    ~> give(allocate-variable(T),
         sequential(initialise-variable(given, Val), given))
Alias
  alloc-init = allocate-initialised-variable
/*
  `allocate-initialised-variable(T, Val)` allocates a simple variable for
  storing values of type `T`, initialises its value to `Val`, and returns the
  variable.
*/

Funcon
  assign(Var:variables, Val:values) : =>null-type
/*
  `assign(Var, Val)` assigns the value `Val` to the variable `Var`,
  provided that `Var` was allocated with a type that contains `Val`.
*/
Rule
  and(is-in-set(L, dom(Sigma)), is-in-type(Val, T)) == true
  -----------------------------------------------------------------------
  < assign(variable(L:locations, T:types), Val:values) ,
    store(Sigma) > ---> < null-value , store(map-override({L|->Val}, Sigma)) >
Rule
   and(is-in-set(L, dom(Sigma)), is-in-type(Val, T)) == false
  --------------------------------------------------------------------------
  < assign(variable(L:locations,T:types), Val:values) ,
    store(Sigma) > ---> < fail , store(Sigma) >

Funcon
  assigned(Var:variables) : =>values
/*
  `assigned(Var)` gives the value assigned to the variable `Var`,
  failing if no value is currently assigned.
*/
Rule
  map-lookup(Sigma, L) ~> Val:values
  ------------------------------------------------------------------
  < assigned(variable(L:locations, T:types)) , store(Sigma) >
    ---> < Val , store(Sigma) >
Rule
  map-lookup(Sigma, L) == ( )
  ------------------------------------------------------------------
  < assigned(variable(L:locations, T:types)) , store(Sigma) >
    ---> < fail , store(Sigma) >

Funcon
  un-assign(Var:variables) : =>null-type
/*
  `un-assign(Var)` remove the value assigned to the variable `Var`.
*/
Rule
  is-in-set(L, dom(Sigma)) == true
  --------------------------------------------------------------------------
  < un-assign(variable(L:locations, T:types)) , store(Sigma) >
    ---> < null-value , store(map-override({L |-> ( )}, Sigma)) >
Rule
   is-in-set(L, dom(Sigma)) == false
  --------------------------------------------------------------------------
  < un-assign(variable(L:locations, T:types)) , store(Sigma) >
    ---> < fail , store(Sigma) >


#### Structured variables

/*
  Structured variables are structured values where some components are
  simple variables. Such component variables can be selected using the
  same funcons as for selecting components of structured values. 

  Structured variables containing both variables and values correspond to
  hybrid structures where particular components are mutable.
  
  All datatypes (except for abstractions) can be used to form structured
  variables. So can maps, but not sets or multisets.
  
  Structural generalisations of `assign(Var, Val)` and 
  `assigned(Var)` access all the simple variables contained in a
  structured variable. Assignment requires each component value of a hybrid
  structured variable to be equal to the corresponding component of the
  structured value.
*/

Funcon
  structural-assign(V1:values, V2:values) : =>null-type
/*
  `structural-assign(V1, V2)` takes a (potentially) structured variable
  `V1`and a (potentially) structured value `V2`. Provided that the structure
  and all non-variable values in `V1` match the structure and corresponding
  values of `V2`, all the simple variables in `V1` are assigned the
  corresponding values of `V2`; otherwise the assignment fails.
*/
Rule
  structural-assign(V1:variables, V2:values)
    ~> assign(V1, V2)
Rule
  I1 =/= "variable"
  -----------------------------------------------------------------------
  structural-assign(datatype-value(I1:identifiers, V1*:values*),
                    datatype-value(I2:identifiers, V2*:values*))
    ~> sequential(
         check-true(is-equal(I1, I2)),
         effect(tuple(interleave-map(
           structural-assign(tuple-elements(given)),
           tuple-zip(tuple(V1*), tuple(V2*))))),
         null-value)
Rule
  dom(M1) == {}
  ------------------------------------------------------
  structural-assign(M1:maps(_,_), M2:maps(_,_))
    ~> check-true(is-equal(dom(M2), { }))
Rule
  some-element(dom(M1)) ~> K
  ----------------------------------------------------------------------------
  structural-assign(M1:maps(_, _), M2:maps(_, _))
    ~> sequential(check-true(is-in-set(K, dom(M2))),
         structural-assign(map-lookup(M1, K), map-lookup(M2, K)),
         structural-assign(map-delete(M1, {K}), map-delete(M2, {K})))
Rule
  V1 : ~(variables|maps(_, _))
  ---------------------------------------------------------------
  structural-assign(V1:values,V2:values)
    ~> check-true(is-equal(V1, V2))

Funcon
  structural-assigned(_:values) : =>values
Alias
  current-value = structural-assigned
/*
  `structural-assigned(V)` takes a (potentially) structured variable `V`,
  and computes the value of `V` with all simple variables in `V` replaced by
  their assigned values, failing if any of them do not have assigned values.
  
  The alias `current-value(V)` is used when `V` is not a structured variable,
  but just a simple variable or a (possibly structured) value with no
  component variables.
*/
Rule
  structural-assigned(Var:variables) ~> assigned(Var)
Rule
  I =/= "variable"
  ----------------------------------------------------------------------------
  structural-assigned(datatype-value(I:identifiers, V*:values*))
    ~> datatype-value(I, interleave-map(structural-assigned(given), V*))
Rule
  structural-assigned(M:maps(_, _))
    ~> map(interleave-map(structural-assigned(given), map-elements(M)))
Rule
  U : ~(variables|maps(_, _))
  ------------------------------------------
  structural-assigned(U:values) ~> U
### Linking

[
  Datatype links
  Funcon   initialise-linking
  Funcon   link
  Funcon   fresh-link
  Funcon   fresh-initialised-link    Alias fresh-init-link
  Funcon   set-link
  Funcon   follow-if-link
]

Meta-variables
  T <: values

Datatype
  links ::= link(_:variables)

Funcon
  initialise-linking(X:=>T) : =>T
   ~> initialise-storing(X)
/*
  `initialise-linking(X)` ensures that the entities used by the funcons for
  linking are properly initialised.
*/

Funcon
  fresh-link(T) : =>links
    ~> link(allocate-variable(T))

Funcon
  fresh-initialised-link(T, V:T) : =>links
    ~> link(allocate-initialised-variable(T, V))
Alias
  fresh-init-link = fresh-initialised-link

Funcon
  set-link(L:links, V:T) : =>null-type
/*
  The value of a link can be set only once.
*/
Rule
  set-link(link(Var:variables),V:T) ~> initialise-variable(Var,V)

Funcon
  follow-link(L:links) : =>values
Rule
  follow-link(link(Var:variables)) ~> assigned(Var)

Funcon
  follow-if-link(V:values) : =>values
/*
  If `V` is a link, `follow-if-link(V)` computes the set value, and
  otherwise it evaluates to `V`.
*/
Rule
  follow-if-link(link(Var:variables)) ~> assigned(Var)
Rule
  follow-if-link(V:~links) ~> V
### Giving

[
  Entity given-value
  Funcon initialise-giving
  Funcon give
  Funcon given
  Funcon no-given
  Funcon left-to-right-map
  Funcon interleave-map
  Funcon left-to-right-repeat
  Funcon interleave-repeat
  Funcon left-to-right-filter
  Funcon interleave-filter
  Funcon fold-left
  Funcon fold-right
]

Meta-variables
  T, T' <: values
  T? <: values?

Entity
  given-value(V:values?) |- _ ---> _
/*
  The given-value entity allows a computation to refer to a single
  previously-computed `V:values`. The given value `( )` represents 
  the absence of a current given value.
*/

Funcon
  initialise-giving(X:( )=>T') : ( )=>T'
   ~> no-given(X)
/*
  `initialise-giving(X)` ensures that the entities used by the funcons for
  giving are properly initialised.
*/

Funcon
  give(V:T, Y:T=>T') : =>T'
/*
  `give(X, Y)` executes `X`, possibly referring to the current `given` value,
  to compute a value `V`. It then executes `Y` with `V` as the `given` value,
  to compute the result.
*/
Rule
  given-value(V) |- Y ---> Y'
  ------------------------------------------------
  given-value(_?) |- give(V:T, Y) ---> give(V, Y')
Rule
  give(V:T, W:T') ~> W

Funcon
  given : T=>T
/*
  `given` refers to the current given value.
*/
Rule
  given-value(V:values) |- given ---> V
Rule
  given-value( ) |- given ---> fail

Funcon
  no-given(_:( )=>T') : ( )=>T'
/*
  `no-given(X)` computes `X` without references to the current given value.
*/
Rule
         given-value( ) |- X ---> X'
  ------------------------------------------------
  given-value(_?) |- no-given(X) ---> no-given(X')
Rule
  no-given(U:T') ~> U


#### Mapping

/*
  Maps on collection values can be expressed directly, e.g.,
  `list(left-to-right-map(F, list-elements(L)))`.
*/

Funcon
  left-to-right-map(F:T=>T', V*:(T)*) : =>(T')*
/*
  `left-to-right-map(F, V*)` computes `F` for each value in `V*` from left
  to right, returning the sequence of resulting values.
*/

Rule
  left-to-right-map(F, V:T, V*:(T)*)
    ~> left-to-right(give(V, F), left-to-right-map(F, V*))
Rule
  left-to-right-map(F, ( )) ~> ( )

Funcon
  interleave-map(F:T=>T', V*:(T)*) : =>(T')*
/*
  `interleave-map(F, V*)` computes `F` for each value in `V*` interleaved, 
  returning the sequence of resulting values.
*/
Rule
  interleave-map(F, V:T, V*:(T)*)
    ~> interleave(give(V, F), interleave-map(F, V*))
Rule
  interleave-map(F, ( )) ~> ( )

Funcon
  left-to-right-repeat(F:integers=>T', M:integers, N:integers) : =>(T')*
/*
  `left-to-right-repeat(F, M, N)` computes `F` for each value from `M` to `N` 
  sequentially, returning the sequence of resulting values.
*/
Rule
  is-less-or-equal(M, N) == true
  -------------------------------------------------------------------------
  left-to-right-repeat(F, M:integers, N:integers)
    ~> left-to-right(give(M, F), left-to-right-repeat(F, int-add(M, 1), N))
Rule
  is-less-or-equal(M, N) == false
  ----------------------------------------------
  left-to-right-repeat(F, M:integers, N:integers) ~> ( )

Funcon
  interleave-repeat(F:integers=>T', M:integers, N:integers) : =>(T')*
/*
  `interleave-repeat(F, M, N)` computes `F` for each value from `M` to `N` 
  interleaved, returning the sequence of resulting values.
*/
Rule
  is-less-or-equal(M, N) == true
  -------------------------------------------------------------------
  interleave-repeat(F, M:integers, N:integers)
    ~> interleave(give(M, F), interleave-repeat(F, int-add(M, 1), N))
Rule
  is-less-or-equal(M, N) == false
  -------------------------------------------
  interleave-repeat(F, M:integers, N:integers) ~> ( )


#### Filtering

/*
  Filters on collections of values can be expressed directly, e.g., 
  `list(left-to-right-filter(P, list-elements(L)))` to filter a list `L`.
*/

Funcon
  left-to-right-filter(P:T=>booleans, V*:(T)*) : =>(T)*
   ~> left-to-right-map(when-true(P, given), V*)
/*
  `left-to-right-filter(P, V*)` computes `P` for each value in `V*` from left
  to right, returning the sequence of argument values for which the result is
  `true`.
*/

Funcon
  interleave-filter(P:T=>booleans, V*:(T)*) : =>(T)*
   ~> interleave-map(when-true(P, given), V*)
/*
  `interleave-filter(P, V*)` computes `P` for each value in `V*` interleaved,
  returning the sequence of argument values for which the result is `true`.
*/


#### Folding

Funcon
  fold-left(F:tuples(T,T')=>T, A:T, V*:(T')*) : =>T
/*
  `fold-left(F, A, V*)` reduces a sequence `V*` to a single value by folding it
  from the left, using `A` as the initial accumulator value, and iteratively
  updating the accumulator by giving `F` the pair of the accumulator value and
  the first of the remaining arguments.
*/
Rule
  fold-left(F, A:T, ( )) ~> A
Rule
  fold-left(F, A:T, V:T', V*:(T')*) ~> fold-left(F, give(tuple(A, V), F), V*)

Funcon
  fold-right(F:tuples(T,T')=>T', A:T', V*:(T)*) : =>T'
/*
  `fold-right(F, A, V*)` reduces a sequence `V*` to a single value by folding it
  from the right, using `A` as the initial accumulator value, and iteratively
  updating the accumulator by giving `F` the pair of the the last of the 
  remaining arguments and the accumulator value.
*/
Rule
  fold-right(_, A:T', ( )) ~> A
Rule
  fold-right(F, A:T', V*:(T)*, V:T) ~> give(tuple(V, fold-right(F, A, V*)), F)
### Generating

[
  Type   atoms
  Entity used-atom-set
  Funcon initialise-generating
  Funcon fresh-atom
  Funcon use-atom-not-in
]

Meta-variables
  T <: values

Built-in Type
  atoms
/*
  `atoms` is the type of values used as distinguishable tags.
  Notation for individual atoms is not provided.
*/

Entity
  < _ , used-atom-set(SA:set(atoms)) > ---> < _ , used-atom-set(SA':set(atoms)) >

Built-in Funcon
  initialise-generating(X:=>T) : =>T
/*
  The initial value of the `used-atom-set(SA)` entity is unspecified. It could
  contains atoms that are reserved for internal use.
*/

Funcon
  fresh-atom : =>atoms
/*
  `fresh-atom` computes an atom distinct from all previously computed atoms.
*/
Rule
  element-not-in(atoms, SA) ~> A
  -----------------------------------------------
  < fresh-atom , used-atom-set(SA) > 
    ---> < A , used-atom-set(set-insert(A, SA)) >

Funcon
  use-atom-not-in(_:sets(atoms)) : =>atoms
/*
  `use-atom-not-in(SA)` computes an atom not in the set `SA`, and inserts it
  in the `used-atom-set(SA')` entity, in case it was not previously used.
*/
Rule
  element-not-in(atoms, SA) ~> A
  --------------------------------------------------------
  < use-atom-not-in(SA:sets(atoms)) , used-atom-set(SA') >
    ---> < A , used-atom-set(set-insert(A, SA')) >
### Binding

[
  Type     environments       Alias envs
  Datatype identifiers        Alias ids
  Funcon   identifier-tagged  Alias id-tagged
  Funcon   fresh-identifier
  Entity   environment        Alias env
  Funcon   initialise-binding
  Funcon   bind-value         Alias bind
  Funcon   unbind
  Funcon   bound-directly
  Funcon   bound-value        Alias bound
  Funcon   closed
  Funcon   scope
  Funcon   accumulate
  Funcon   collateral
  Funcon   bind-recursively
  Funcon   recursive
]

Meta-variables
  T <: values

#### Environments

Type
  environments ~> maps(identifiers, values?)
Alias
  envs = environments
/*
  An environment represents bindings of identifiers to values.
  Mapping an identifier to `( )` represents that its binding is hidden.
  
  Circularity in environments (due to recursive bindings) is represented using
  bindings to cut-points called `links`. Funcons are provided for making
  declarations recursive and for referring to bound values without explicit
  mention of links, so their existence can generally be ignored.
*/

Datatype
  identifiers ::= {_:strings} | identifier-tagged(_:identifiers, _:values)
Alias
  ids = identifiers
Alias
  id-tagged = identifier-tagged
/*
  An identifier is either a string of characters, or an identifier tagged with
  some value (e.g., with the identifier of a namespace).
*/

Funcon
  fresh-identifier : =>identifiers
/*
  `fresh-identifier` computes an identifier distinct from all previously
  computed identifiers.
*/
Rule
  fresh-identifier ~> identifier-tagged("generated", fresh-atom)

#### Current bindings

Entity
  environment(_:environments) |- _ ---> _
Alias
  env = environment
/*
  The environment entity allows a computation to refer to the current bindings
  of identifiers to values.
*/

Funcon
  initialise-binding(X:=>T) : =>T
   ~> initialise-linking(initialise-generating(closed(X)))
/*
  `initialise-binding(X)` ensures that `X` does not depend on non-local bindings.
  It also ensures that the linking entity (used to represent potentially cyclic
  bindings) and the generating entity (for creating fresh identifiers) are 
  initialised.
*/

Funcon
  bind-value(I:identifiers, V:values) : =>environments
    ~> { I |-> V }
Alias
  bind = bind-value
/*
  `bind-value(I, X)` computes the environment that binds only `I` to the value
  computed by `X`.
*/
  
Funcon
  unbind(I:identifiers) : =>environments
    ~> { I |-> ( ) }
/*
  `unbind(I)` computes the environment that hides the binding of `I`.
*/

Funcon
  bound-directly(I:identifiers) : =>values
/* 
  `bound-directly(I)` returns the value to which `I` is currently bound, if any,
  and otherwise fails.

  `bound-directly(I)` does *not* follow links. It is used only in connection with
  recursively-bound values when references are not encapsulated in abstractions.
*/
Rule 
  lookup(Rho, I) ~> V:values
  --------------------------------------------------------
  environment(Rho) |- bound-directly(I:identifiers) ---> V
Rule 
  lookup(Rho, I) ~> ( )
  -----------------------------------------------------------
  environment(Rho) |- bound-directly(I:identifiers) ---> fail

Funcon
  bound-value(I:identifiers) : =>values
   ~> follow-if-link(bound-directly(I))
Alias
  bound = bound-value
/* 
   `bound-value(I)` inspects the value to which `I` is currently bound, if any,
   and otherwise fails. If the value is a link, `bound-value(I)` returns the
   value obtained by following the link, if any, and otherwise fails. If the 
   inspected value is not a link, `bound-value(I)` returns it. 
   
   `bound-value(I)` is used for references to non-recursive bindings and to
   recursively-bound values when references are encapsulated in abstractions.
*/

#### Scope

Funcon
  closed(X:=>T) : =>T
/*
  `closed(X)` ensures that `X` does not depend on non-local bindings.
*/
Rule
  environment(map( )) |- X ---> X'
  -------------------------------------------
  environment(_) |- closed(X) ---> closed(X')
Rule
  closed(V:T) ~> V

Funcon
  scope(Rho:environments, X:=>T) : =>T
/*
  `scope(D,X)` executes `D` with the current bindings, to compute an environment
  `Rho` representing local bindings. It then executes `X` to compute the result,
  with the current bindings extended by `Rho`, which may shadow or hide previous
  bindings.
  
  `closed(scope(Rho, X))` ensures that `X` can reference only the bindings
  provided by `Rho`.
*/
Rule
  environment(map-override(Rho1, Rho0)) |- X ---> X'
  ---------------------------------------------------------------------
  environment(Rho0) |- scope(Rho1:environments, X) ---> scope(Rho1, X')
Rule
  scope(_:environments, V:T) ~> V

Funcon
  accumulate(D*:(=>environments)*) : =>environments
/*
  `accumulate(D1, D2)` executes `D1` with the current bindings, to compute an
  environment `Rho1` representing some local bindings. It then executes `D2` to
  compute an environment `Rho2` representing further local bindings, with the
  current bindings extended by `Rho1`, which may shadow or hide previous
  current bindings. The result is `Rho1` extended by `Rho2`, which may shadow
  or hide the bindings of `Rho1`.
  
  `accumulate(_, _)` is associative, with `map( )` as unit, and extends to any
  number of arguments.
*/
Rule
                  D1 ---> D1'
  -------------------------------------------
  accumulate(D1, D2) ---> accumulate(D1', D2)
Rule
  accumulate(Rho1:environments, D2) ~> scope(Rho1, map-override(D2, Rho1))
Rule
  accumulate( ) ~> map( )
Rule
  accumulate(D1) ~> D1
Rule
  accumulate(D1, D2, D+) ~> accumulate(D1, accumulate(D2, D+))

Funcon
  collateral(Rho*:environments*) : =>environments
   ~> checked map-unite(Rho*)
/* 
  `collateral(D1, ...)` pre-evaluates its arguments with the current bindings,
  and unites the resulting maps, which fails if the domains are not pairwise
  disjoint.

  `collateral(D1, D2)` is associative and commutative with `map( )` as unit, 
  and extends to any number of arguments.
*/

#### Recurse

Funcon
  bind-recursively(I:identifiers, E:=>values) : =>environments
    ~> recursive({I}, bind-value(I, E))
/*
  `bind-recursively(I, E)` binds `I` to a link that refers to the value of `E`, 
  representing a recursive binding of `I` to the value of `E`.
  Since `bound-value(I)` follows links, it should not be executed during the
  evaluation of `E`.
*/

Funcon
  recursive(SI:sets(identifiers), D:=>environments) : =>environments
    ~> re-close(bind-to-forward-links(SI), D)
/*
  `recursive(SI, D)` executes `D` with potential recursion on the bindings of 
  the identifiers in the set `SI` (which need not be the same as the set of
  identifiers bound by `D`).
*/

Auxiliary Funcon
  re-close(M:maps(identifiers, links), D:=>environments) : =>environments
    ~> accumulate(scope(M, D), sequential(set-forward-links(M), map( )))
/*
  `re-close(M, D)` first executes `D` in the scope `M`, which maps identifiers
  to freshly allocated links. This computes an environment `Rho` where the bound
  values may contain links, or implicit references to links in abstraction
  values. It then sets the link for each identifier in the domain of `M` to
  refer to its bound value in `Rho`, and returns `Rho` as the result.
*/

Auxiliary Funcon
  bind-to-forward-links(SI:sets(identifiers)) : =>maps(identifiers, links)
    ~> map-unite(interleave-map(bind-value(given, fresh-link(values)), 
                                set-elements(SI)))
/*
  `bind-to-forward-links(SI)` binds each identifier in the set `SI` to a
  freshly allocated link.
*/

Auxiliary Funcon
  set-forward-links(M:maps(identifiers, links)) : =>null-type
    ~> effect(interleave-map(set-link(map-lookup(M, given), bound-value(given)),
                             set-elements(map-domain(M))))
/*
  For each identifier `I` in the domain of `M`, `set-forward-links(M)` sets the 
  link to which `I` is mapped by `M` to the current bound value of `I`.
*/
## Computation Types

Built-in Funcon
  computation-types : types
/*
  For any value type `T`, the term `=>T` is the type of computations that
  compute values of type `T` whenever they terminate normally.
  
  For any subtypes `T`, `T'` of `values`, `T=>T'` is the type of computations
  that compute values of type `T'` whenever they terminate normally, and
  either do not refer at all to the `given` entity, or require the `given`
  entity to have type `T`.
*/
### Abruptly terminating

[
  Funcon stuck
  Entity abrupted
  Funcon finalise-abrupting
  Funcon abrupt
  Funcon handle-abrupt
  Funcon finally
]

Meta-variables
  T, T', T'' <: values

Funcon
  stuck : =>empty-type
/*
  `stuck` does not have any computation. It is used to represent the result of
  a transition that causes the computation to terminate abruptly.
*/

Entity
  _ --abrupted(V?:values?)-> _
/*
  `abrupted(V)` in a label on a tranistion indicates abrupt termination for
  reason `V`. `abrupted( )` indicates the absence of abrupt termination.
*/

Funcon
  finalise-abrupting(X:=>T) : =>T|null-type
   ~> handle-abrupt(X, null-value)
/*
  `finalise-abrupting(X)` handles abrupt termination of `X` for any reason.
*/

Funcon
  abrupt(V:values) :=>empty-type
/*
  `abrupt(V)` terminates abruptly for reason `V`.
*/
Rule
  abrupt(V:values) --abrupted(V)-> stuck

Funcon
  handle-abrupt(X:T'=>T, Y:T''=>T) : T'=>T
/*
  `handle-abrupt(X, Y)` first evaluates `X`. If `X` terminates normally with
  value `V`, then `V` is returned and `Y` is ignored. If `X` terminates abruptly
  for reason `V`, then `Y` is executed with `V` as `given` value.

  `handle-abrupt(X, Y)` is associative, with `abrupt(given)` as left and right
  unit. `handle-abrupt(X, else(Y, abrupt(given)))` ensures propagation of 
  abrupt termination for the given reason if `Y` fails
*/
Rule
                    X --abrupted( )-> X'
  --------------------------------------------------------
  handle-abrupt(X, Y) --abrupted( )-> handle-abrupt(X', Y)
Rule
                    X --abrupted(V:T'')-> X'
  ----------------------------------------------
  handle-abrupt(X, Y) --abrupted( )-> give(V, Y)
Rule
  handle-abrupt(V:T, Y) ~> V

Funcon
  finally(X:=>T, Y:=>null-type) : =>T
/*
  `finally(X, Y)` first executes `X`. If `X` terminates normally with 
  value `V`, then `Y` is executed before terminating normally with value `V`.
  If `X` terminates abruptly for reason `V`, then `Y` is executed before
  terminating abruptly with the same reason `V`.
*/
Rule
              X --abrupted( )-> X'
  --------------------------------------------
  finally(X, Y) --abrupted( )-> finally(X', Y)
Rule
              X --abrupted(V:values)-> X'
  -----------------------------------------------------
  finally(X, Y) --abrupted()-> sequential(Y, abrupt(V))
Rule
  finally(V:T, Y) ~> sequential(Y,V)
  
### Returning

[
  Datatype returning
  Funcon   returned
  Funcon   finalise-returning
  Funcon   return
  Funcon   handle-return
]

Meta-variables
  T <: values

Datatype
  returning ::= returned(_:values)
/*
  `returned(V?)` is a reason for abrupt termination.
*/

Funcon
  finalise-returning(X:=>T) : =>T|null-type
   ~> finalise-abrupting(X)
/*
  `finalise-returning(X)` handles abrupt termination of `X` due to
  executing `return(V)`.
*/

Funcon
  return(V:T) : =>empty-type
   ~> abrupt(returned(V))
/*
  `return(V)` abruptly terminates all enclosing computations until it is
  handled, then giving `V`. Note that `V` may be `null-value`.
*/

Funcon
  handle-return(X:=>T) : =>T
/*
  `handle-return(X)` first evaluates `X`. If `X` either terminates abruptly for 
  reason `returned(V)`, or terminates normally with value `V`, it gives `V`.
*/
Rule
                 X --abrupted( )-> X'
  --------------------------------------------------
  handle-return(X) --abrupted( )-> handle-return(X')
Rule
  X --abrupted(returned(V:values))-> X'
  ----------------------------------------------
  handle-return(X) --abrupted( )-> V
Rule
                 X --abrupted(V':~returning)-> X'
  ---------------------------------------------------
  handle-return(X) --abrupted(V')-> handle-return(X')
Rule
  handle-return(V:T) ~> V
### Controlling

[
  Datatype continuations
  Funcon   continuation
  Entity   plug-signal
  Funcon   hole
  Funcon   resume-continuation
  Entity   control-signal
  Funcon   control
  Funcon   delimit-current-continuation  Alias delimit-cc
]

Meta-variables
  T, T1, T2 <: values

Datatype
  continuations(T1,T2) ::= continuation(_:abstractions(null-type=>T2))
/*
  `continuations(T1, T2)` consists of abstractions whose bodies contain a `hole`,
  and which will normally compute a value of type `T2` when the `hole` is plugged
  with a value of type `T1`.
*/

Entity
  _ --plug-signal(V?:values?)-> _
/*
   A plug-signal contains the value to be filled into a `hole` in a continuation,
   thereby allowing a continuation to resume.
*/

 Funcon
  hole : =>values
/*
  A `hole` in a term cannot proceed until it receives a plug-signal
  containing a value to plug the hole.
*/
Rule
 hole --plug-signal(V)-> V

Funcon
  resume-continuation(K:continuations(T1, T2), V:T1) : =>T2
/*
 `resume-continuation(K, V)` resumes a continuation `K` by plugging the value
 `V` into the `hole` in the continuation.
*/
Rule
                  X --plug-signal(V)-> X'
 ----------------------------------------------------------------------------
 resume-continuation(continuation(abstraction(X)), V:T) --plug-signal()-> X'


Entity
  _ --control-signal(F?:(functions(continuations(T1, T2), T2))?)-> _
/*
   A control-signal contains the function to which control is about to be passed
   by the enclosing `delimit-current-continuation(X)`.
*/

Funcon
  control(F:functions(continuations(T1, T2), T2)) : =>T1
/*
  `control(F)` emits a control-signal that, when handled by an enclosing
  `delimit-current-continuation(X)`, will apply `F` to the current continuation of
  `control(F)`, (rather than proceeding with that current continuation).
*/
Rule
  control(F:functions(_,_)) --control-signal(F)-> hole


Funcon
  delimit-current-continuation(X:=>T) : =>T
Alias
  delimit-cc = delimit-current-continuation
/*
  `delimit-current-continuation(X)` delimits the scope of captured continuations.
*/
Rule
  delimit-current-continuation(V:T) ~> V
Rule
                         X --control-signal( )-> X'
  -----------------------------------------------------
  delimit-current-continuation(X) --control-signal( )->
    delimit-current-continuation(X')
Rule
                         X --control-signal(F)-> X'
  ------------------------------------------------------------------
  delimit-current-continuation(X) --control-signal( )->
    delimit-current-continuation(apply(F, continuation closure(X')))
### Throwing

[
  Datatype throwing
  Funcon   thrown
  Funcon   finalise-throwing
  Funcon   throw
  Funcon   handle-thrown
  Funcon   handle-recursively
  Funcon   catch-else-throw
]

Meta-variables
  R, S, T, T', T'' <: values

Datatype
  throwing ::= thrown(_:values)
/*
  `thrown(V)` is a reason for abrupt termination.
*/

Funcon
  finalise-throwing(X:=>T) : =>T|null-type
   ~> finalise-abrupting(X)
/*
  `finalise-throwing(X)` handles abrupt termination of `X` due to
  executing `throw(V)`.
*/

Funcon
  throw(V:T) : =>empty-type
   ~> abrupt(thrown(V))
/*
  `throw(V)` abruptly terminates all enclosing computations uTil it is handled.
*/

Funcon
  handle-thrown(X:T'=>T, Y:T''=>T) : T'=>T
/*
  `handle-thrown(X, Y)` first evaluates `X`. If `X` terminates normally with
  value `V`, then `V` is returned and `Y` is ignored. If `X` terminates abruptly
  with a thrown eTity having value `V`, then `Y` is executed with `V` as
  `given` value.
  
  `handle-thrown(X, Y)` is associative, with `throw(given)` as unit.
  `handle-thrown(X, else(Y, throw(given)))` ensures that if `Y` fails, the
  thrown value is re-thrown.
*/
Rule
                    X --abrupted( )-> X'
  --------------------------------------------------------
  handle-thrown(X, Y) --abrupted( )-> handle-thrown(X', Y)
Rule
    X --abrupted(thrown(V'':values))-> X'
  ----------------------------------------------
  handle-thrown(X, Y) --abrupted( )-> give(V'', Y)
Rule
                    X --abrupted(V':~throwing)-> X'
  ---------------------------------------------------------
  handle-thrown(X, Y) --abrupted(V')-> handle-thrown(X', Y)
Rule
  handle-thrown(V:T, Y) ~> V

Funcon
  handle-recursively(X:S=>T, Y:R=>T) : S=>T
    ~> handle-thrown(X, else(handle-recursively(Y, Y), throw(given)))
/*
  `handle-recursively(X, Y)` behaves similarly to `handle-thrown(X, Y)`, except
  that another copy of the handler attempts to handle any values thrown by `Y`.
  Thus, many thrown values may get handled by the same handler. 
*/

Funcon
  catch-else-throw(P:values, Y:=>T) : =>T
    ~> else(case-match(P, Y), throw(given))
 /*
   `handle-thrown(X, catch-else-throw(P, Y))` handles those values thrown by `X`
   that match pattern `P`.  Other thrown values are re-thrown.  
 */
### Failing

[
  Datatype failing
  Funcon   failed
  Funcon   finalise-failing
  Funcon   fail
  Funcon   else
  Funcon   else-choice
  Funcon   checked
  Funcon   check-true
]

Meta-variables
  T <: values

Datatype
  failing ::= failed
/*
  `failed` is a reason for abrupt termination.
*/

Funcon
  finalise-failing(X:=>T) : =>T|null-type
   ~> finalise-abrupting(X)
/*
  `finalise-failing(X)` handles abrupt termination of `X` due to executing `fail`.
*/

Funcon
  fail : =>empty-type
   ~> abrupt(failed)
/*
  `fail` abruptly terminates all enclosing computations until it is handled.
*/

Funcon
  else(X:=>T, X+:(=>T)+) : =>T
/*
  `else(X1, X2, ...)` executes the arguments in turn until either some
  `Xi` does *not* fail, or all arguments `Xi` have been executed.
  The last argument executed determines the result.
  `else(X, Y)` is associative, with unit `fail`.
*/
Rule
           X --abrupted( )-> X'
  --------------------------------------
  else(X, Y) --abrupted( )-> else(X', Y)
Rule
           X --abrupted(failed)-> _
  ---------------------------------
  else(X, Y) --abrupted( )-> Y
Rule
           X --abrupted(V:~failing)-> X'
  --------------------------------------
  else(X, Y) --abrupted(V)-> else(X', Y)
Rule
  else(V:T, Y) ~> V
Rule
  else(X, Y, Z+) ~> else(X, else(Y, Z+))

Funcon
  else-choice(X+:(=>T)+) : =>T
/*
  `else-choice(X,...)` executes the arguments in any order until either some
  `Xi` does *not* fail, or all arguments `Xi` have been executed.
  The last argument executed determines the result.
  `else(X, Y)` is associative and commutative, with unit `fail`.
*/
Rule
  else-choice(W*, X, Y, Z*)
   ~> choice(else(X, else-choice(W*, Y, Z*), 
             else(Y, else-choice(W*, X, Z*))))
Rule
  else-choice(X) ~> X

Funcon
  check-true(B:booleans) : =>null-type
Alias
  check = check-true
/*
  `check-true(X)` terminates normally if the value computed by `X` is `true`,
  and fails if it is `false`.
*/
Rule
  check-true(true)  ~> null-value
Rule
  check-true(false) ~> fail

Funcon 
  checked(_:(T)?) : =>T
/*
  `checked(X)` fails when `X` gives the empty sequence of values `( )`,
  representing that an optional value has not been computed. It otherwise
  computes the same as `X`.
*/
Rule
  checked(V:T) ~> V
Rule
  checked( ) ~> fail
### Breaking

[
  Datatype breaking
  Funcon   broken
  Funcon   finalise-breaking
  Funcon   break
  Funcon   handle-break
]

Meta-variables
  T <: values

Datatype
  breaking ::= broken
/*
  `broken` is a reason for abrupt termination.
*/

Funcon
  finalise-breaking(X:=>T) : =>T|null-type
   ~> finalise-abrupting(X)
/*
  `finalise-breaking(X)` handles abrupt termination of `X` due to executing
  `break`.
*/

Funcon
  break : =>empty-type
   ~> abrupt(broken)
/*
  `break` abruptly terminates all enclosing computations until it is handled.
*/

Funcon
  handle-break(X:=>null-type) : =>null-type
/*
  `handle-break(X)` terminates normally when `X` terminates abruptly for the
  reason `broken`.
*/
Rule
                X --abrupted( )-> X'
  ------------------------------------------------
  handle-break(X) --abrupted( )-> handle-break(X')
Rule
                X --abrupted(broken)-> _
  ---------------------------------------
  handle-break(X) --abrupted( )-> null-value
Rule
                X --abrupted(V:~breaking)-> X'
  ------------------------------------------------
  handle-break(X) --abrupted(V)-> handle-break(X')
Rule
  handle-break(null-value) ~> null-value
### Continuing

[
  Datatype continuing
  Funcon   continued
  Funcon   finalise-continuing
  Funcon   continue
  Funcon   handle-continue
]

Meta-variables
  T <: values

Datatype
  continuing ::= continued
/*
  `continued` is a reason for abrupt termination.
*/

Funcon
  finalise-continuing(X:=>T) : =>T|null-type
   ~> finalise-abrupting(X)
/*
  `finalise-continuing(X)` handles abrupt termination of `X` due to executing
  `continue`.
*/

Funcon
  continue : =>empty-type
   ~> abrupt(continued)
/*
  `continue` abruptly terminates all enclosing computations until it is handled.
*/

Funcon
  handle-continue(X:=>null-type) : =>null-type
/*
  `handle-continue(X)` terminates normally when `X` terminates abruptly for the
  reason `continued`.
*/
Rule
                   X --abrupted( )-> X'
  ------------------------------------------------------
  handle-continue(X) --abrupted( )-> handle-continue(X')
Rule
                   X --abrupted(continued)-> _
  --------------------------------------------
  handle-continue(X) --abrupted( )-> null-value
Rule
                   X --abrupted(V:~continuing)-> X'
  ------------------------------------------------------
  handle-continue(X) --abrupted(V)-> handle-continue(X')
Rule
  handle-continue(null-value) ~> null-value
# Computations

## Types of computation
[
  Funcon   computation-types
]

## Normal computation

### Flowing
[
  Funcon   left-to-right   Alias l-to-r
  Funcon   right-to-left   Alias r-to-l
  Funcon   sequential      Alias seq
  Funcon   effect
  Funcon   choice
  Funcon   if-true-else    Alias if-else
  Funcon   while-true      Alias while
  Funcon   do-while-true   Alias do-while
  Funcon   interleave
  Datatype yielding
  Funcon   signal
  Funcon   yielded
  Funcon   yield
  Funcon   yield-on-value
  Funcon   yield-on-abrupt
  Funcon   atomic
]

### Giving
[
  Entity   given-value
  Funcon   initialise-giving
  Funcon   give
  Funcon   given
  Funcon   no-given
  Funcon   left-to-right-map
  Funcon   interleave-map
  Funcon   left-to-right-repeat
  Funcon   interleave-repeat
  Funcon   left-to-right-filter
  Funcon   interleave-filter
  Funcon   fold-left
  Funcon   fold-right
]

### Binding
[
  Type     environments       Alias envs
  Datatype identifiers        Alias ids
  Funcon   identifier-tagged  Alias id-tagged
  Funcon   fresh-identifier
  Entity   environment        Alias env
  Funcon   initialise-binding
  Funcon   bind-value         Alias bind
  Funcon   unbind
  Funcon   bound-directly
  Funcon   bound-value        Alias bound
  Funcon   closed
  Funcon   scope
  Funcon   accumulate
  Funcon   collateral
  Funcon   bind-recursively
  Funcon   recursive
]

### Generating
[
  Type     atoms
  Entity   used-atom-set
  Funcon   initialise-generating
  Funcon   fresh-atom
  Funcon   use-atom-not-in
]

### Storing
[
  Datatype locations                     Alias locs
  Type     stores
  Entity   store
  Funcon   initialise-storing
  Funcon   store-clear
  Datatype variables                     Alias vars
  Funcon   variable                      Alias var
  Funcon   allocate-variable             Alias alloc
  Funcon   recycle-variables             Alias recycle
  Funcon   initialise-variable           Alias init
  Funcon   allocate-initialised-variable Alias alloc-init
  Funcon   assign
  Funcon   assigned
  Funcon   un-assign
  Funcon   structural-assign
  Funcon   structural-assigned           Alias current-value
]

### Linking
[
  Datatype links
  Funcon   initialise-linking
  Funcon   link
  Funcon   fresh-link
  Funcon   fresh-initialised-link    Alias fresh-init-link
  Funcon   set-link
  Funcon   follow-if-link
]

### Interacting

#### Input
[
  Entity   standard-in
  Funcon   read
]

#### Output
[
  Entity   standard-out
  Funcon   print
]

## Abnormal computation

### Terminating abruptly
[
  Funcon   stuck
  Entity   abrupted
  Funcon   finalise-abrupting
  Funcon   abrupt
  Funcon   handle-abrupt
  Funcon   finally
]

### Failing
[
  Datatype failing
  Funcon   failed
  Funcon   finalise-failing
  Funcon   fail
  Funcon   else
  Funcon   else-choice
  Funcon   checked
  Funcon   check-true
]

### Throwing
[
  Datatype throwing
  Funcon   thrown
  Funcon   finalise-throwing
  Funcon   throw
  Funcon   handle-thrown
  Funcon   handle-recursively
  Funcon   catch-else-throw
]

### Returning
[
  Datatype returning
  Funcon   returned
  Funcon   finalise-returning
  Funcon   return
  Funcon   handle-return
]

### Breaking
[
  Datatype breaking
  Funcon   broken
  Funcon   finalise-breaking
  Funcon   break
  Funcon   handle-break
]

### Continuing
[
  Datatype continuing
  Funcon   continued
  Funcon   finalise-continuing
  Funcon   continue
  Funcon   handle-continue
]

### Controlling
[
  Datatype continuations
  Funcon   continuation
  Entity   plug-signal
  Funcon   hole
  Funcon   resume-continuation
  Entity   control-signal
  Funcon   control
  Funcon   delimit-current-continuation  Alias delimit-cc
]


# Values

## Value Types
[ 
  Type   values           Alias vals
  Type   value-types      Alias types
  Type   empty-type
  Funcon is-in-type       Alias is
  Funcon is-value         Alias is-val
  Funcon when-true        Alias when
  Type   cast-to-type     Alias cast
  Type   ground-values    Alias ground-vals
  Funcon is-equal         Alias is-eq
]

## Primitive values

### Booleans
[
  Datatype booleans      Alias bools
  Funcon   true
  Funcon   false
  Funcon   not
  Funcon   implies
  Funcon   and
  Funcon   or
  Funcon   exclusive-or  Alias xor
]

### Integers
[
  Type     integers                     Alias ints
  Type     integers-from                Alias from
  Type     integers-up-to               Alias up-to
  Type     bounded-integers             Alias bounded-ints
  Type     positive-integers            Alias pos-ints
  Type     negative-integers            Alias neg-ints
  Type     natural-numbers              Alias nats
  Funcon   natural-successor            Alias nat-succ
  Funcon   natural-predecessor          Alias nat-pred
  Funcon   integer-add                  Alias int-add
  Funcon   integer-subtract             Alias int-sub
  Funcon   integer-multiply             Alias int-mul
  Funcon   integer-divide               Alias int-div
  Funcon   integer-modulo               Alias int-mod
  Funcon   integer-power                Alias int-pow
  Funcon   integer-absolute-value       Alias int-abs
  Funcon   integer-negate               Alias int-neg
  Funcon   integer-is-less              Alias is-less
  Funcon   integer-is-less-or-equal     Alias is-less-or-equal
  Funcon   integer-is-greater           Alias is-greater
  Funcon   integer-is-greater-or-equal  Alias is-greater-or-equal
  Funcon   binary-natural               Alias binary
  Funcon   octal-natural                Alias octal
  Funcon   decimal-natural              Alias decimal
  Funcon   hexadecimal-natural          Alias hexadecimal
  Funcon   integer-sequence
]

### Floats
[
  Datatype float-formats
  Funcon   binary32
  Funcon   binary64
  Funcon   binary128
  Funcon   decimal64
  Funcon   decimal128
  Type     floats
  Funcon   float
  Funcon   quiet-not-a-number       Alias qNaN
  Funcon   signaling-not-a-number   Alias sNaN
  Funcon   positive-infinity        Alias pos-inf
  Funcon   negative-infinity        Alias neg-inf
  Funcon   float-convert
  Funcon   float-equal
  Funcon   float-is-less
  Funcon   float-is-less-or-equal
  Funcon   float-is-greater
  Funcon   float-is-greater-or-equal
  Funcon   float-negate
  Funcon   float-absolute-value
  Funcon   float-add
  Funcon   float-subtract
  Funcon   float-multiply
  Funcon   float-multiply-add
  Funcon   float-divide
  Funcon   float-remainder
  Funcon   float-sqrt
  Funcon   float-integer-power
  Funcon   float-float-power
  Funcon   float-round-ties-to-even
  Funcon   float-round-ties-to-infinity
  Funcon   float-floor
  Funcon   float-ceiling
  Funcon   float-truncate
  Funcon   float-pi
  Funcon   float-e
  Funcon   float-log
  Funcon   float-log10
  Funcon   float-exp
  Funcon   float-sin
  Funcon   float-cos
  Funcon   float-tan
  Funcon   float-asin
  Funcon   float-acos
  Funcon   float-atan
  Funcon   float-sinh
  Funcon   float-cosh
  Funcon   float-tanh
  Funcon   float-asinh
  Funcon   float-acosh
  Funcon   float-atanh
  Funcon   float-atan2
]

### Characters
[
  Type     characters                          Alias chars
  Datatype unicode-characters                  Alias unicode-chars
  Type     unicode-points
  Funcon   unicode-character                   Alias char
  Funcon   unicode-point                       Alias unicode
  Type     basic-multilingual-plane-characters Alias bmp-chars
  Type     basic-multilingual-plane-points
  Type     iso-latin-1-characters              Alias latin-1-chars
  Type     iso-latin-1-points
  Type     ascii-characters                    Alias ascii-chars
  Type     ascii-points
  Funcon   utf-8
  Funcon   utf-16
  Funcon   utf-32
  Funcon   backspace
  Funcon   horizontal-tab
  Funcon   line-feed
  Funcon   form-feed
  Funcon   carriage-return
  Funcon   double-quote
  Funcon   single-quote
  Funcon   backslash
]

### The null value

[
  Datatype null-type
  Funcon   null-value Alias null
]

## Composite values

### Sequences of values
[
  Funcon   length
  Funcon   index
  Funcon   first
  Funcon   second
  Funcon   third
  Funcon   is-in
  Funcon   first-n
  Funcon   drop-first-n
  Funcon   reverse
  Funcon   n-of
  Funcon   intersperse
]

### Datatypes
[
  Funcon   datatype-value
  Funcon   datatype-value-id
  Funcon   datatype-value-elements
]

### Tuples
[
  Datatype tuples
  Funcon   tuple-elements
  Funcon   tuple-zip
]

### Lists
[
  Datatype lists
  Funcon   list
  Funcon   list-elements
  Funcon   list-nil       Alias nil
  Funcon   list-cons      Alias cons
  Funcon   list-head      Alias head
  Funcon   list-tail      Alias tail
  Funcon   list-length
  Funcon   list-append
]

### Strings
[
  Type     strings
  Funcon   string
  Funcon   string-append
  Funcon   to-string
]

### Vectors
[
  Datatype vectors
  Funcon   vector
  Funcon   vector-elements
]

### Bits and bit vectors
[
  Type     bits
  Datatype bit-vectors
  Funcon   bit-vector
  Type     bytes             Alias octets
  Funcon   bit-vector-not
  Funcon   bit-vector-and
  Funcon   bit-vector-or
  Funcon   bit-vector-xor
  Funcon   bit-vector-shift-left
  Funcon   bit-vector-logical-shift-right
  Funcon   bit-vector-arithmetic-shift-right
  Funcon   integer-to-bit-vector
  Funcon   bit-vector-to-integer
  Funcon   bit-vector-to-natural
  Funcon   unsigned-bit-vector-maximum
  Funcon   signed-bit-vector-maximum
  Funcon   signed-bit-vector-minimum
  Funcon   is-in-signed-bit-vector
  Funcon   is-in-unsigned-bit-vector
]

### Sets
[
  Type     sets
  Funcon   set
  Funcon   set-elements
  Funcon   is-in-set
  Funcon   is-subset
  Funcon   set-insert
  Funcon   set-unite
  Funcon   set-intersect
  Funcon   set-difference
  Funcon   set-size
  Funcon   some-element
  Funcon   element-not-in
]

### Maps
[
  Type     maps
  Funcon   map
  Funcon   map-elements
  Funcon   map-lookup    Alias lookup
  Funcon   map-domain    Alias dom
  Funcon   map-override
  Funcon   map-unite
  Funcon   map-delete
]

### Multisets (bags)
[
  Type     multisets
  Funcon   multiset
  Funcon   multiset-elements
  Funcon   multiset-occurrences
  Funcon   multiset-insert
  Funcon   multiset-delete
  Funcon   is-submultiset
]

### Trees
[
  Datatype trees
  Funcon   tree
  Funcon   tree-root-value
  Funcon   tree-branch-sequence
  Funcon   single-branching-sequence
  Funcon   forest-root-value-sequence
  Funcon   forest-branch-sequence
  Funcon   forest-value-sequence
]

### Graphs
[
  Type     directed-graphs
  Funcon   is-cyclic
  Funcon   topological-sort
]

### References and pointers
[
  Datatype references
  Funcon   reference
  Type     pointers
  Funcon   dereference
]

### Records
[
  Datatype records
  Funcon   record
  Funcon   record-map
  Funcon   record-select
]

### Variants
[
  Datatype variants
  Funcon   variant
  Funcon   variant-id
  Funcon   variant-value
]

### Classes
[
  Datatype classes
  Funcon   class
  Funcon   class-instantiator
  Funcon   class-feature-map
  Funcon   class-superclass-name-sequence
  Funcon   class-name-tree
  Funcon   is-subclass-name
  Funcon   class-name-single-inheritance-feature-map
]

### Objects
[
  Datatype objects
  Funcon   object
  Funcon   object-identity
  Funcon   object-class-name
  Funcon   object-feature-map
  Funcon   object-subobject-sequence
  Funcon   object-tree
  Funcon   object-single-inheritance-feature-map
]

## Abstraction values

### Generic abstractions
[
  Type     abstractions
  Funcon   abstraction
  Funcon   closure
  Funcon   enact
]

### Thunks
[
  Datatype thunks
  Funcon   thunk
  Funcon   force
]

### Functions
[
  Datatype functions
  Funcon   function
  Funcon   apply
  Funcon   supply
  Funcon   compose
  Funcon   uncurry
  Funcon   curry
  Funcon   partial-apply
]

### Patterns
[
  Datatype patterns
  Funcon   pattern
  Funcon   pattern-any
  Funcon   pattern-bind
  Funcon   pattern-type
  Funcon   pattern-else
  Funcon   pattern-unite
  Funcon   match
  Funcon   match-loosely
  Funcon   case-match
  Funcon   case-match-loosely
  Funcon   case-variant-value
]
## Value Types

[ 
  Type   values           Alias vals
  Type   value-types      Alias types
  Type   empty-type
  Funcon is-in-type       Alias is
  Funcon is-value         Alias is-val
  Funcon when-true        Alias when
  Type   cast-to-type     Alias cast
  Type   ground-values    Alias ground-vals
  Funcon is-equal         Alias is-eq
]



